// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: UIData.proto

#ifndef PROTOBUF_UIData_2eproto__INCLUDED
#define PROTOBUF_UIData_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace message {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_UIData_2eproto();
void protobuf_AssignDesc_UIData_2eproto();
void protobuf_ShutdownFile_UIData_2eproto();

class UI;
class UI_Field;

enum UI_Field_Anchor {
  UI_Field_Anchor_Anchor_Centre = 0,
  UI_Field_Anchor_Anchor_LEFT_UP = 1,
  UI_Field_Anchor_Anchor_LEFT_DOWN = 2,
  UI_Field_Anchor_Anchor_LEFT_Centre = 3,
  UI_Field_Anchor_Anchor_RIGHT_UP = 4,
  UI_Field_Anchor_Anchor_RIGHT_DOWN = 5,
  UI_Field_Anchor_Anchor_RIGHT_Centre = 6,
  UI_Field_Anchor_Anchor_UP_Centre = 7,
  UI_Field_Anchor_Anchor_DOWN_Centre = 8
};
bool UI_Field_Anchor_IsValid(int value);
const UI_Field_Anchor UI_Field_Anchor_Anchor_MIN = UI_Field_Anchor_Anchor_Centre;
const UI_Field_Anchor UI_Field_Anchor_Anchor_MAX = UI_Field_Anchor_Anchor_DOWN_Centre;
const int UI_Field_Anchor_Anchor_ARRAYSIZE = UI_Field_Anchor_Anchor_MAX + 1;

enum UI_Field_ElementType {
  UI_Field_ElementType_ElementType_UnKnow = 0,
  UI_Field_ElementType_ElementType_Sprite = 1,
  UI_Field_ElementType_ElementType_Menu = 2,
  UI_Field_ElementType_ElementType_Panel = 3,
  UI_Field_ElementType_ElementType_Spx = 4
};
bool UI_Field_ElementType_IsValid(int value);
const UI_Field_ElementType UI_Field_ElementType_ElementType_MIN = UI_Field_ElementType_ElementType_UnKnow;
const UI_Field_ElementType UI_Field_ElementType_ElementType_MAX = UI_Field_ElementType_ElementType_Spx;
const int UI_Field_ElementType_ElementType_ARRAYSIZE = UI_Field_ElementType_ElementType_MAX + 1;

// ===================================================================

class UI_Field : public ::google::protobuf::MessageLite {
 public:
  UI_Field();
  virtual ~UI_Field();

  UI_Field(const UI_Field& from);

  inline UI_Field& operator=(const UI_Field& from) {
    CopyFrom(from);
    return *this;
  }

  static const UI_Field& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UI_Field* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UI_Field* other);

  // implements Message ----------------------------------------------

  UI_Field* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UI_Field& from);
  void MergeFrom(const UI_Field& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef UI_Field_Anchor Anchor;
  static const Anchor Anchor_Centre = UI_Field_Anchor_Anchor_Centre;
  static const Anchor Anchor_LEFT_UP = UI_Field_Anchor_Anchor_LEFT_UP;
  static const Anchor Anchor_LEFT_DOWN = UI_Field_Anchor_Anchor_LEFT_DOWN;
  static const Anchor Anchor_LEFT_Centre = UI_Field_Anchor_Anchor_LEFT_Centre;
  static const Anchor Anchor_RIGHT_UP = UI_Field_Anchor_Anchor_RIGHT_UP;
  static const Anchor Anchor_RIGHT_DOWN = UI_Field_Anchor_Anchor_RIGHT_DOWN;
  static const Anchor Anchor_RIGHT_Centre = UI_Field_Anchor_Anchor_RIGHT_Centre;
  static const Anchor Anchor_UP_Centre = UI_Field_Anchor_Anchor_UP_Centre;
  static const Anchor Anchor_DOWN_Centre = UI_Field_Anchor_Anchor_DOWN_Centre;
  static inline bool Anchor_IsValid(int value) {
    return UI_Field_Anchor_IsValid(value);
  }
  static const Anchor Anchor_MIN =
    UI_Field_Anchor_Anchor_MIN;
  static const Anchor Anchor_MAX =
    UI_Field_Anchor_Anchor_MAX;
  static const int Anchor_ARRAYSIZE =
    UI_Field_Anchor_Anchor_ARRAYSIZE;

  typedef UI_Field_ElementType ElementType;
  static const ElementType ElementType_UnKnow = UI_Field_ElementType_ElementType_UnKnow;
  static const ElementType ElementType_Sprite = UI_Field_ElementType_ElementType_Sprite;
  static const ElementType ElementType_Menu = UI_Field_ElementType_ElementType_Menu;
  static const ElementType ElementType_Panel = UI_Field_ElementType_ElementType_Panel;
  static const ElementType ElementType_Spx = UI_Field_ElementType_ElementType_Spx;
  static inline bool ElementType_IsValid(int value) {
    return UI_Field_ElementType_IsValid(value);
  }
  static const ElementType ElementType_MIN =
    UI_Field_ElementType_ElementType_MIN;
  static const ElementType ElementType_MAX =
    UI_Field_ElementType_ElementType_MAX;
  static const int ElementType_ARRAYSIZE =
    UI_Field_ElementType_ElementType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional string resName = 1;
  inline bool has_resname() const;
  inline void clear_resname();
  static const int kResNameFieldNumber = 1;
  inline const ::std::string& resname() const;
  inline void set_resname(const ::std::string& value);
  inline void set_resname(const char* value);
  inline void set_resname(const char* value, size_t size);
  inline ::std::string* mutable_resname();
  inline ::std::string* release_resname();
  inline void set_allocated_resname(::std::string* resname);

  // optional string objectName = 2 [default = ""];
  inline bool has_objectname() const;
  inline void clear_objectname();
  static const int kObjectNameFieldNumber = 2;
  inline const ::std::string& objectname() const;
  inline void set_objectname(const ::std::string& value);
  inline void set_objectname(const char* value);
  inline void set_objectname(const char* value, size_t size);
  inline ::std::string* mutable_objectname();
  inline ::std::string* release_objectname();
  inline void set_allocated_objectname(::std::string* objectname);

  // optional .message.UI.Field.ElementType elementType = 3 [default = ElementType_UnKnow];
  inline bool has_elementtype() const;
  inline void clear_elementtype();
  static const int kElementTypeFieldNumber = 3;
  inline ::message::UI_Field_ElementType elementtype() const;
  inline void set_elementtype(::message::UI_Field_ElementType value);

  // optional string describe = 4 [default = ""];
  inline bool has_describe() const;
  inline void clear_describe();
  static const int kDescribeFieldNumber = 4;
  inline const ::std::string& describe() const;
  inline void set_describe(const ::std::string& value);
  inline void set_describe(const char* value);
  inline void set_describe(const char* value, size_t size);
  inline ::std::string* mutable_describe();
  inline ::std::string* release_describe();
  inline void set_allocated_describe(::std::string* describe);

  // optional float srcPointX = 5;
  inline bool has_srcpointx() const;
  inline void clear_srcpointx();
  static const int kSrcPointXFieldNumber = 5;
  inline float srcpointx() const;
  inline void set_srcpointx(float value);

  // optional float srcPointY = 6;
  inline bool has_srcpointy() const;
  inline void clear_srcpointy();
  static const int kSrcPointYFieldNumber = 6;
  inline float srcpointy() const;
  inline void set_srcpointy(float value);

  // optional float dstPointX = 7;
  inline bool has_dstpointx() const;
  inline void clear_dstpointx();
  static const int kDstPointXFieldNumber = 7;
  inline float dstpointx() const;
  inline void set_dstpointx(float value);

  // optional float dstPointY = 8;
  inline bool has_dstpointy() const;
  inline void clear_dstpointy();
  static const int kDstPointYFieldNumber = 8;
  inline float dstpointy() const;
  inline void set_dstpointy(float value);

  // optional float imageW = 9;
  inline bool has_imagew() const;
  inline void clear_imagew();
  static const int kImageWFieldNumber = 9;
  inline float imagew() const;
  inline void set_imagew(float value);

  // optional float imageH = 10;
  inline bool has_imageh() const;
  inline void clear_imageh();
  static const int kImageHFieldNumber = 10;
  inline float imageh() const;
  inline void set_imageh(float value);

  // optional float originX = 11;
  inline bool has_originx() const;
  inline void clear_originx();
  static const int kOriginXFieldNumber = 11;
  inline float originx() const;
  inline void set_originx(float value);

  // optional float originY = 12;
  inline bool has_originy() const;
  inline void clear_originy();
  static const int kOriginYFieldNumber = 12;
  inline float originy() const;
  inline void set_originy(float value);

  // optional bool isVisible = 13 [default = true];
  inline bool has_isvisible() const;
  inline void clear_isvisible();
  static const int kIsVisibleFieldNumber = 13;
  inline bool isvisible() const;
  inline void set_isvisible(bool value);

  // optional int32 opacity = 14 [default = 255];
  inline bool has_opacity() const;
  inline void clear_opacity();
  static const int kOpacityFieldNumber = 14;
  inline ::google::protobuf::int32 opacity() const;
  inline void set_opacity(::google::protobuf::int32 value);

  // optional float scaleX = 15 [default = 1];
  inline bool has_scalex() const;
  inline void clear_scalex();
  static const int kScaleXFieldNumber = 15;
  inline float scalex() const;
  inline void set_scalex(float value);

  // optional float scaleY = 16 [default = 1];
  inline bool has_scaley() const;
  inline void clear_scaley();
  static const int kScaleYFieldNumber = 16;
  inline float scaley() const;
  inline void set_scaley(float value);

  // optional float rotation = 17 [default = 0];
  inline bool has_rotation() const;
  inline void clear_rotation();
  static const int kRotationFieldNumber = 17;
  inline float rotation() const;
  inline void set_rotation(float value);

  // optional float skewX = 18 [default = 0];
  inline bool has_skewx() const;
  inline void clear_skewx();
  static const int kSkewXFieldNumber = 18;
  inline float skewx() const;
  inline void set_skewx(float value);

  // optional float skewY = 19 [default = 0];
  inline bool has_skewy() const;
  inline void clear_skewy();
  static const int kSkewYFieldNumber = 19;
  inline float skewy() const;
  inline void set_skewy(float value);

  // optional .message.UI.Field.Anchor anchor = 20 [default = Anchor_Centre];
  inline bool has_anchor() const;
  inline void clear_anchor();
  static const int kAnchorFieldNumber = 20;
  inline ::message::UI_Field_Anchor anchor() const;
  inline void set_anchor(::message::UI_Field_Anchor value);

  // optional float intervalTime = 21;
  inline bool has_intervaltime() const;
  inline void clear_intervaltime();
  static const int kIntervalTimeFieldNumber = 21;
  inline float intervaltime() const;
  inline void set_intervaltime(float value);

  // optional string event = 22;
  inline bool has_event() const;
  inline void clear_event();
  static const int kEventFieldNumber = 22;
  inline const ::std::string& event() const;
  inline void set_event(const ::std::string& value);
  inline void set_event(const char* value);
  inline void set_event(const char* value, size_t size);
  inline ::std::string* mutable_event();
  inline ::std::string* release_event();
  inline void set_allocated_event(::std::string* event);

  // optional int32 id = 23;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 23;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // repeated int32 childIDList = 24;
  inline int childidlist_size() const;
  inline void clear_childidlist();
  static const int kChildIDListFieldNumber = 24;
  inline ::google::protobuf::int32 childidlist(int index) const;
  inline void set_childidlist(int index, ::google::protobuf::int32 value);
  inline void add_childidlist(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      childidlist() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_childidlist();

  // optional bool isChildType = 25 [default = false];
  inline bool has_ischildtype() const;
  inline void clear_ischildtype();
  static const int kIsChildTypeFieldNumber = 25;
  inline bool ischildtype() const;
  inline void set_ischildtype(bool value);

  // repeated .message.UI.Field childList = 26;
  inline int childlist_size() const;
  inline void clear_childlist();
  static const int kChildListFieldNumber = 26;
  inline const ::message::UI_Field& childlist(int index) const;
  inline ::message::UI_Field* mutable_childlist(int index);
  inline ::message::UI_Field* add_childlist();
  inline const ::google::protobuf::RepeatedPtrField< ::message::UI_Field >&
      childlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::UI_Field >*
      mutable_childlist();

  // @@protoc_insertion_point(class_scope:message.UI.Field)
 private:
  inline void set_has_resname();
  inline void clear_has_resname();
  inline void set_has_objectname();
  inline void clear_has_objectname();
  inline void set_has_elementtype();
  inline void clear_has_elementtype();
  inline void set_has_describe();
  inline void clear_has_describe();
  inline void set_has_srcpointx();
  inline void clear_has_srcpointx();
  inline void set_has_srcpointy();
  inline void clear_has_srcpointy();
  inline void set_has_dstpointx();
  inline void clear_has_dstpointx();
  inline void set_has_dstpointy();
  inline void clear_has_dstpointy();
  inline void set_has_imagew();
  inline void clear_has_imagew();
  inline void set_has_imageh();
  inline void clear_has_imageh();
  inline void set_has_originx();
  inline void clear_has_originx();
  inline void set_has_originy();
  inline void clear_has_originy();
  inline void set_has_isvisible();
  inline void clear_has_isvisible();
  inline void set_has_opacity();
  inline void clear_has_opacity();
  inline void set_has_scalex();
  inline void clear_has_scalex();
  inline void set_has_scaley();
  inline void clear_has_scaley();
  inline void set_has_rotation();
  inline void clear_has_rotation();
  inline void set_has_skewx();
  inline void clear_has_skewx();
  inline void set_has_skewy();
  inline void clear_has_skewy();
  inline void set_has_anchor();
  inline void clear_has_anchor();
  inline void set_has_intervaltime();
  inline void clear_has_intervaltime();
  inline void set_has_event();
  inline void clear_has_event();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_ischildtype();
  inline void clear_has_ischildtype();

  ::std::string* resname_;
  ::std::string* objectname_;
  ::std::string* describe_;
  int elementtype_;
  float srcpointx_;
  float srcpointy_;
  float dstpointx_;
  float dstpointy_;
  float imagew_;
  float imageh_;
  float originx_;
  float originy_;
  ::google::protobuf::int32 opacity_;
  float scalex_;
  float scaley_;
  float rotation_;
  float skewx_;
  float skewy_;
  bool isvisible_;
  bool ischildtype_;
  int anchor_;
  float intervaltime_;
  ::std::string* event_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > childidlist_;
  ::google::protobuf::RepeatedPtrField< ::message::UI_Field > childlist_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(26 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_UIData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_UIData_2eproto();
  #endif
  friend void protobuf_AssignDesc_UIData_2eproto();
  friend void protobuf_ShutdownFile_UIData_2eproto();

  void InitAsDefaultInstance();
  static UI_Field* default_instance_;
};
// -------------------------------------------------------------------

class UI : public ::google::protobuf::MessageLite {
 public:
  UI();
  virtual ~UI();

  UI(const UI& from);

  inline UI& operator=(const UI& from) {
    CopyFrom(from);
    return *this;
  }

  static const UI& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UI* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UI* other);

  // implements Message ----------------------------------------------

  UI* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UI& from);
  void MergeFrom(const UI& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef UI_Field Field;

  // accessors -------------------------------------------------------

  // required string layerName = 1;
  inline bool has_layername() const;
  inline void clear_layername();
  static const int kLayerNameFieldNumber = 1;
  inline const ::std::string& layername() const;
  inline void set_layername(const ::std::string& value);
  inline void set_layername(const char* value);
  inline void set_layername(const char* value, size_t size);
  inline ::std::string* mutable_layername();
  inline ::std::string* release_layername();
  inline void set_allocated_layername(::std::string* layername);

  // repeated .message.UI.Field fieldList = 2;
  inline int fieldlist_size() const;
  inline void clear_fieldlist();
  static const int kFieldListFieldNumber = 2;
  inline const ::message::UI_Field& fieldlist(int index) const;
  inline ::message::UI_Field* mutable_fieldlist(int index);
  inline ::message::UI_Field* add_fieldlist();
  inline const ::google::protobuf::RepeatedPtrField< ::message::UI_Field >&
      fieldlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::UI_Field >*
      mutable_fieldlist();

  // optional string version = 3 [default = "V.13.06.27"];
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:message.UI)
 private:
  inline void set_has_layername();
  inline void clear_has_layername();
  inline void set_has_version();
  inline void clear_has_version();

  ::std::string* layername_;
  ::google::protobuf::RepeatedPtrField< ::message::UI_Field > fieldlist_;
  ::std::string* version_;
  static ::std::string* _default_version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_UIData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_UIData_2eproto();
  #endif
  friend void protobuf_AssignDesc_UIData_2eproto();
  friend void protobuf_ShutdownFile_UIData_2eproto();

  void InitAsDefaultInstance();
  static UI* default_instance_;
};
// ===================================================================


// ===================================================================

// UI_Field

// optional string resName = 1;
inline bool UI_Field::has_resname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UI_Field::set_has_resname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UI_Field::clear_has_resname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UI_Field::clear_resname() {
  if (resname_ != &::google::protobuf::internal::kEmptyString) {
    resname_->clear();
  }
  clear_has_resname();
}
inline const ::std::string& UI_Field::resname() const {
  return *resname_;
}
inline void UI_Field::set_resname(const ::std::string& value) {
  set_has_resname();
  if (resname_ == &::google::protobuf::internal::kEmptyString) {
    resname_ = new ::std::string;
  }
  resname_->assign(value);
}
inline void UI_Field::set_resname(const char* value) {
  set_has_resname();
  if (resname_ == &::google::protobuf::internal::kEmptyString) {
    resname_ = new ::std::string;
  }
  resname_->assign(value);
}
inline void UI_Field::set_resname(const char* value, size_t size) {
  set_has_resname();
  if (resname_ == &::google::protobuf::internal::kEmptyString) {
    resname_ = new ::std::string;
  }
  resname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UI_Field::mutable_resname() {
  set_has_resname();
  if (resname_ == &::google::protobuf::internal::kEmptyString) {
    resname_ = new ::std::string;
  }
  return resname_;
}
inline ::std::string* UI_Field::release_resname() {
  clear_has_resname();
  if (resname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resname_;
    resname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UI_Field::set_allocated_resname(::std::string* resname) {
  if (resname_ != &::google::protobuf::internal::kEmptyString) {
    delete resname_;
  }
  if (resname) {
    set_has_resname();
    resname_ = resname;
  } else {
    clear_has_resname();
    resname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string objectName = 2 [default = ""];
inline bool UI_Field::has_objectname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UI_Field::set_has_objectname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UI_Field::clear_has_objectname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UI_Field::clear_objectname() {
  if (objectname_ != &::google::protobuf::internal::kEmptyString) {
    objectname_->clear();
  }
  clear_has_objectname();
}
inline const ::std::string& UI_Field::objectname() const {
  return *objectname_;
}
inline void UI_Field::set_objectname(const ::std::string& value) {
  set_has_objectname();
  if (objectname_ == &::google::protobuf::internal::kEmptyString) {
    objectname_ = new ::std::string;
  }
  objectname_->assign(value);
}
inline void UI_Field::set_objectname(const char* value) {
  set_has_objectname();
  if (objectname_ == &::google::protobuf::internal::kEmptyString) {
    objectname_ = new ::std::string;
  }
  objectname_->assign(value);
}
inline void UI_Field::set_objectname(const char* value, size_t size) {
  set_has_objectname();
  if (objectname_ == &::google::protobuf::internal::kEmptyString) {
    objectname_ = new ::std::string;
  }
  objectname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UI_Field::mutable_objectname() {
  set_has_objectname();
  if (objectname_ == &::google::protobuf::internal::kEmptyString) {
    objectname_ = new ::std::string;
  }
  return objectname_;
}
inline ::std::string* UI_Field::release_objectname() {
  clear_has_objectname();
  if (objectname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = objectname_;
    objectname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UI_Field::set_allocated_objectname(::std::string* objectname) {
  if (objectname_ != &::google::protobuf::internal::kEmptyString) {
    delete objectname_;
  }
  if (objectname) {
    set_has_objectname();
    objectname_ = objectname;
  } else {
    clear_has_objectname();
    objectname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .message.UI.Field.ElementType elementType = 3 [default = ElementType_UnKnow];
inline bool UI_Field::has_elementtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UI_Field::set_has_elementtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UI_Field::clear_has_elementtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UI_Field::clear_elementtype() {
  elementtype_ = 0;
  clear_has_elementtype();
}
inline ::message::UI_Field_ElementType UI_Field::elementtype() const {
  return static_cast< ::message::UI_Field_ElementType >(elementtype_);
}
inline void UI_Field::set_elementtype(::message::UI_Field_ElementType value) {
  assert(::message::UI_Field_ElementType_IsValid(value));
  set_has_elementtype();
  elementtype_ = value;
}

// optional string describe = 4 [default = ""];
inline bool UI_Field::has_describe() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UI_Field::set_has_describe() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UI_Field::clear_has_describe() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UI_Field::clear_describe() {
  if (describe_ != &::google::protobuf::internal::kEmptyString) {
    describe_->clear();
  }
  clear_has_describe();
}
inline const ::std::string& UI_Field::describe() const {
  return *describe_;
}
inline void UI_Field::set_describe(const ::std::string& value) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(value);
}
inline void UI_Field::set_describe(const char* value) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(value);
}
inline void UI_Field::set_describe(const char* value, size_t size) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UI_Field::mutable_describe() {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  return describe_;
}
inline ::std::string* UI_Field::release_describe() {
  clear_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = describe_;
    describe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UI_Field::set_allocated_describe(::std::string* describe) {
  if (describe_ != &::google::protobuf::internal::kEmptyString) {
    delete describe_;
  }
  if (describe) {
    set_has_describe();
    describe_ = describe;
  } else {
    clear_has_describe();
    describe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float srcPointX = 5;
inline bool UI_Field::has_srcpointx() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UI_Field::set_has_srcpointx() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UI_Field::clear_has_srcpointx() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UI_Field::clear_srcpointx() {
  srcpointx_ = 0;
  clear_has_srcpointx();
}
inline float UI_Field::srcpointx() const {
  return srcpointx_;
}
inline void UI_Field::set_srcpointx(float value) {
  set_has_srcpointx();
  srcpointx_ = value;
}

// optional float srcPointY = 6;
inline bool UI_Field::has_srcpointy() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UI_Field::set_has_srcpointy() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UI_Field::clear_has_srcpointy() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UI_Field::clear_srcpointy() {
  srcpointy_ = 0;
  clear_has_srcpointy();
}
inline float UI_Field::srcpointy() const {
  return srcpointy_;
}
inline void UI_Field::set_srcpointy(float value) {
  set_has_srcpointy();
  srcpointy_ = value;
}

// optional float dstPointX = 7;
inline bool UI_Field::has_dstpointx() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UI_Field::set_has_dstpointx() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UI_Field::clear_has_dstpointx() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UI_Field::clear_dstpointx() {
  dstpointx_ = 0;
  clear_has_dstpointx();
}
inline float UI_Field::dstpointx() const {
  return dstpointx_;
}
inline void UI_Field::set_dstpointx(float value) {
  set_has_dstpointx();
  dstpointx_ = value;
}

// optional float dstPointY = 8;
inline bool UI_Field::has_dstpointy() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UI_Field::set_has_dstpointy() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UI_Field::clear_has_dstpointy() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UI_Field::clear_dstpointy() {
  dstpointy_ = 0;
  clear_has_dstpointy();
}
inline float UI_Field::dstpointy() const {
  return dstpointy_;
}
inline void UI_Field::set_dstpointy(float value) {
  set_has_dstpointy();
  dstpointy_ = value;
}

// optional float imageW = 9;
inline bool UI_Field::has_imagew() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UI_Field::set_has_imagew() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UI_Field::clear_has_imagew() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UI_Field::clear_imagew() {
  imagew_ = 0;
  clear_has_imagew();
}
inline float UI_Field::imagew() const {
  return imagew_;
}
inline void UI_Field::set_imagew(float value) {
  set_has_imagew();
  imagew_ = value;
}

// optional float imageH = 10;
inline bool UI_Field::has_imageh() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UI_Field::set_has_imageh() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UI_Field::clear_has_imageh() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UI_Field::clear_imageh() {
  imageh_ = 0;
  clear_has_imageh();
}
inline float UI_Field::imageh() const {
  return imageh_;
}
inline void UI_Field::set_imageh(float value) {
  set_has_imageh();
  imageh_ = value;
}

// optional float originX = 11;
inline bool UI_Field::has_originx() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UI_Field::set_has_originx() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UI_Field::clear_has_originx() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UI_Field::clear_originx() {
  originx_ = 0;
  clear_has_originx();
}
inline float UI_Field::originx() const {
  return originx_;
}
inline void UI_Field::set_originx(float value) {
  set_has_originx();
  originx_ = value;
}

// optional float originY = 12;
inline bool UI_Field::has_originy() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UI_Field::set_has_originy() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UI_Field::clear_has_originy() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UI_Field::clear_originy() {
  originy_ = 0;
  clear_has_originy();
}
inline float UI_Field::originy() const {
  return originy_;
}
inline void UI_Field::set_originy(float value) {
  set_has_originy();
  originy_ = value;
}

// optional bool isVisible = 13 [default = true];
inline bool UI_Field::has_isvisible() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void UI_Field::set_has_isvisible() {
  _has_bits_[0] |= 0x00001000u;
}
inline void UI_Field::clear_has_isvisible() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void UI_Field::clear_isvisible() {
  isvisible_ = true;
  clear_has_isvisible();
}
inline bool UI_Field::isvisible() const {
  return isvisible_;
}
inline void UI_Field::set_isvisible(bool value) {
  set_has_isvisible();
  isvisible_ = value;
}

// optional int32 opacity = 14 [default = 255];
inline bool UI_Field::has_opacity() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void UI_Field::set_has_opacity() {
  _has_bits_[0] |= 0x00002000u;
}
inline void UI_Field::clear_has_opacity() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void UI_Field::clear_opacity() {
  opacity_ = 255;
  clear_has_opacity();
}
inline ::google::protobuf::int32 UI_Field::opacity() const {
  return opacity_;
}
inline void UI_Field::set_opacity(::google::protobuf::int32 value) {
  set_has_opacity();
  opacity_ = value;
}

// optional float scaleX = 15 [default = 1];
inline bool UI_Field::has_scalex() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void UI_Field::set_has_scalex() {
  _has_bits_[0] |= 0x00004000u;
}
inline void UI_Field::clear_has_scalex() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void UI_Field::clear_scalex() {
  scalex_ = 1;
  clear_has_scalex();
}
inline float UI_Field::scalex() const {
  return scalex_;
}
inline void UI_Field::set_scalex(float value) {
  set_has_scalex();
  scalex_ = value;
}

// optional float scaleY = 16 [default = 1];
inline bool UI_Field::has_scaley() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void UI_Field::set_has_scaley() {
  _has_bits_[0] |= 0x00008000u;
}
inline void UI_Field::clear_has_scaley() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void UI_Field::clear_scaley() {
  scaley_ = 1;
  clear_has_scaley();
}
inline float UI_Field::scaley() const {
  return scaley_;
}
inline void UI_Field::set_scaley(float value) {
  set_has_scaley();
  scaley_ = value;
}

// optional float rotation = 17 [default = 0];
inline bool UI_Field::has_rotation() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void UI_Field::set_has_rotation() {
  _has_bits_[0] |= 0x00010000u;
}
inline void UI_Field::clear_has_rotation() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void UI_Field::clear_rotation() {
  rotation_ = 0;
  clear_has_rotation();
}
inline float UI_Field::rotation() const {
  return rotation_;
}
inline void UI_Field::set_rotation(float value) {
  set_has_rotation();
  rotation_ = value;
}

// optional float skewX = 18 [default = 0];
inline bool UI_Field::has_skewx() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void UI_Field::set_has_skewx() {
  _has_bits_[0] |= 0x00020000u;
}
inline void UI_Field::clear_has_skewx() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void UI_Field::clear_skewx() {
  skewx_ = 0;
  clear_has_skewx();
}
inline float UI_Field::skewx() const {
  return skewx_;
}
inline void UI_Field::set_skewx(float value) {
  set_has_skewx();
  skewx_ = value;
}

// optional float skewY = 19 [default = 0];
inline bool UI_Field::has_skewy() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void UI_Field::set_has_skewy() {
  _has_bits_[0] |= 0x00040000u;
}
inline void UI_Field::clear_has_skewy() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void UI_Field::clear_skewy() {
  skewy_ = 0;
  clear_has_skewy();
}
inline float UI_Field::skewy() const {
  return skewy_;
}
inline void UI_Field::set_skewy(float value) {
  set_has_skewy();
  skewy_ = value;
}

// optional .message.UI.Field.Anchor anchor = 20 [default = Anchor_Centre];
inline bool UI_Field::has_anchor() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void UI_Field::set_has_anchor() {
  _has_bits_[0] |= 0x00080000u;
}
inline void UI_Field::clear_has_anchor() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void UI_Field::clear_anchor() {
  anchor_ = 0;
  clear_has_anchor();
}
inline ::message::UI_Field_Anchor UI_Field::anchor() const {
  return static_cast< ::message::UI_Field_Anchor >(anchor_);
}
inline void UI_Field::set_anchor(::message::UI_Field_Anchor value) {
  assert(::message::UI_Field_Anchor_IsValid(value));
  set_has_anchor();
  anchor_ = value;
}

// optional float intervalTime = 21;
inline bool UI_Field::has_intervaltime() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void UI_Field::set_has_intervaltime() {
  _has_bits_[0] |= 0x00100000u;
}
inline void UI_Field::clear_has_intervaltime() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void UI_Field::clear_intervaltime() {
  intervaltime_ = 0;
  clear_has_intervaltime();
}
inline float UI_Field::intervaltime() const {
  return intervaltime_;
}
inline void UI_Field::set_intervaltime(float value) {
  set_has_intervaltime();
  intervaltime_ = value;
}

// optional string event = 22;
inline bool UI_Field::has_event() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void UI_Field::set_has_event() {
  _has_bits_[0] |= 0x00200000u;
}
inline void UI_Field::clear_has_event() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void UI_Field::clear_event() {
  if (event_ != &::google::protobuf::internal::kEmptyString) {
    event_->clear();
  }
  clear_has_event();
}
inline const ::std::string& UI_Field::event() const {
  return *event_;
}
inline void UI_Field::set_event(const ::std::string& value) {
  set_has_event();
  if (event_ == &::google::protobuf::internal::kEmptyString) {
    event_ = new ::std::string;
  }
  event_->assign(value);
}
inline void UI_Field::set_event(const char* value) {
  set_has_event();
  if (event_ == &::google::protobuf::internal::kEmptyString) {
    event_ = new ::std::string;
  }
  event_->assign(value);
}
inline void UI_Field::set_event(const char* value, size_t size) {
  set_has_event();
  if (event_ == &::google::protobuf::internal::kEmptyString) {
    event_ = new ::std::string;
  }
  event_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UI_Field::mutable_event() {
  set_has_event();
  if (event_ == &::google::protobuf::internal::kEmptyString) {
    event_ = new ::std::string;
  }
  return event_;
}
inline ::std::string* UI_Field::release_event() {
  clear_has_event();
  if (event_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = event_;
    event_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UI_Field::set_allocated_event(::std::string* event) {
  if (event_ != &::google::protobuf::internal::kEmptyString) {
    delete event_;
  }
  if (event) {
    set_has_event();
    event_ = event;
  } else {
    clear_has_event();
    event_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 id = 23;
inline bool UI_Field::has_id() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void UI_Field::set_has_id() {
  _has_bits_[0] |= 0x00400000u;
}
inline void UI_Field::clear_has_id() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void UI_Field::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 UI_Field::id() const {
  return id_;
}
inline void UI_Field::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// repeated int32 childIDList = 24;
inline int UI_Field::childidlist_size() const {
  return childidlist_.size();
}
inline void UI_Field::clear_childidlist() {
  childidlist_.Clear();
}
inline ::google::protobuf::int32 UI_Field::childidlist(int index) const {
  return childidlist_.Get(index);
}
inline void UI_Field::set_childidlist(int index, ::google::protobuf::int32 value) {
  childidlist_.Set(index, value);
}
inline void UI_Field::add_childidlist(::google::protobuf::int32 value) {
  childidlist_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
UI_Field::childidlist() const {
  return childidlist_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
UI_Field::mutable_childidlist() {
  return &childidlist_;
}

// optional bool isChildType = 25 [default = false];
inline bool UI_Field::has_ischildtype() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void UI_Field::set_has_ischildtype() {
  _has_bits_[0] |= 0x01000000u;
}
inline void UI_Field::clear_has_ischildtype() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void UI_Field::clear_ischildtype() {
  ischildtype_ = false;
  clear_has_ischildtype();
}
inline bool UI_Field::ischildtype() const {
  return ischildtype_;
}
inline void UI_Field::set_ischildtype(bool value) {
  set_has_ischildtype();
  ischildtype_ = value;
}

// repeated .message.UI.Field childList = 26;
inline int UI_Field::childlist_size() const {
  return childlist_.size();
}
inline void UI_Field::clear_childlist() {
  childlist_.Clear();
}
inline const ::message::UI_Field& UI_Field::childlist(int index) const {
  return childlist_.Get(index);
}
inline ::message::UI_Field* UI_Field::mutable_childlist(int index) {
  return childlist_.Mutable(index);
}
inline ::message::UI_Field* UI_Field::add_childlist() {
  return childlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::UI_Field >&
UI_Field::childlist() const {
  return childlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::UI_Field >*
UI_Field::mutable_childlist() {
  return &childlist_;
}

// -------------------------------------------------------------------

// UI

// required string layerName = 1;
inline bool UI::has_layername() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UI::set_has_layername() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UI::clear_has_layername() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UI::clear_layername() {
  if (layername_ != &::google::protobuf::internal::kEmptyString) {
    layername_->clear();
  }
  clear_has_layername();
}
inline const ::std::string& UI::layername() const {
  return *layername_;
}
inline void UI::set_layername(const ::std::string& value) {
  set_has_layername();
  if (layername_ == &::google::protobuf::internal::kEmptyString) {
    layername_ = new ::std::string;
  }
  layername_->assign(value);
}
inline void UI::set_layername(const char* value) {
  set_has_layername();
  if (layername_ == &::google::protobuf::internal::kEmptyString) {
    layername_ = new ::std::string;
  }
  layername_->assign(value);
}
inline void UI::set_layername(const char* value, size_t size) {
  set_has_layername();
  if (layername_ == &::google::protobuf::internal::kEmptyString) {
    layername_ = new ::std::string;
  }
  layername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UI::mutable_layername() {
  set_has_layername();
  if (layername_ == &::google::protobuf::internal::kEmptyString) {
    layername_ = new ::std::string;
  }
  return layername_;
}
inline ::std::string* UI::release_layername() {
  clear_has_layername();
  if (layername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = layername_;
    layername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UI::set_allocated_layername(::std::string* layername) {
  if (layername_ != &::google::protobuf::internal::kEmptyString) {
    delete layername_;
  }
  if (layername) {
    set_has_layername();
    layername_ = layername;
  } else {
    clear_has_layername();
    layername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .message.UI.Field fieldList = 2;
inline int UI::fieldlist_size() const {
  return fieldlist_.size();
}
inline void UI::clear_fieldlist() {
  fieldlist_.Clear();
}
inline const ::message::UI_Field& UI::fieldlist(int index) const {
  return fieldlist_.Get(index);
}
inline ::message::UI_Field* UI::mutable_fieldlist(int index) {
  return fieldlist_.Mutable(index);
}
inline ::message::UI_Field* UI::add_fieldlist() {
  return fieldlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::UI_Field >&
UI::fieldlist() const {
  return fieldlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::UI_Field >*
UI::mutable_fieldlist() {
  return &fieldlist_;
}

// optional string version = 3 [default = "V.13.06.27"];
inline bool UI::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UI::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UI::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UI::clear_version() {
  if (version_ != _default_version_) {
    version_->assign(*_default_version_);
  }
  clear_has_version();
}
inline const ::std::string& UI::version() const {
  return *version_;
}
inline void UI::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == _default_version_) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void UI::set_version(const char* value) {
  set_has_version();
  if (version_ == _default_version_) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void UI::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == _default_version_) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UI::mutable_version() {
  set_has_version();
  if (version_ == _default_version_) {
    version_ = new ::std::string(*_default_version_);
  }
  return version_;
}
inline ::std::string* UI::release_version() {
  clear_has_version();
  if (version_ == _default_version_) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(_default_version_);
    return temp;
  }
}
inline void UI::set_allocated_version(::std::string* version) {
  if (version_ != _default_version_) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(_default_version_);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace message

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_UIData_2eproto__INCLUDED
