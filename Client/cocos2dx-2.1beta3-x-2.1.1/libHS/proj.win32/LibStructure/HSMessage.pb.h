// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: HSMessage.proto

#ifndef PROTOBUF_HSMessage_2eproto__INCLUDED
#define PROTOBUF_HSMessage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace message {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_HSMessage_2eproto();
void protobuf_AssignDesc_HSMessage_2eproto();
void protobuf_ShutdownFile_HSMessage_2eproto();

class MessageInfo;
class Head;
class Body;

// ===================================================================

class MessageInfo : public ::google::protobuf::MessageLite {
 public:
  MessageInfo();
  virtual ~MessageInfo();

  MessageInfo(const MessageInfo& from);

  inline MessageInfo& operator=(const MessageInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const MessageInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MessageInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MessageInfo* other);

  // implements Message ----------------------------------------------

  MessageInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MessageInfo& from);
  void MergeFrom(const MessageInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .message.Head head = 1;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 1;
  inline const ::message::Head& head() const;
  inline ::message::Head* mutable_head();
  inline ::message::Head* release_head();
  inline void set_allocated_head(::message::Head* head);

  // required .message.Body body = 2;
  inline bool has_body() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 2;
  inline const ::message::Body& body() const;
  inline ::message::Body* mutable_body();
  inline ::message::Body* release_body();
  inline void set_allocated_body(::message::Body* body);

  // @@protoc_insertion_point(class_scope:message.MessageInfo)
 private:
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_body();
  inline void clear_has_body();

  ::message::Head* head_;
  ::message::Body* body_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_HSMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_HSMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_HSMessage_2eproto();
  friend void protobuf_ShutdownFile_HSMessage_2eproto();

  void InitAsDefaultInstance();
  static MessageInfo* default_instance_;
};
// -------------------------------------------------------------------

class Head : public ::google::protobuf::MessageLite {
 public:
  Head();
  virtual ~Head();

  Head(const Head& from);

  inline Head& operator=(const Head& from) {
    CopyFrom(from);
    return *this;
  }

  static const Head& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Head* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Head* other);

  // implements Message ----------------------------------------------

  Head* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Head& from);
  void MergeFrom(const Head& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional string imei = 2;
  inline bool has_imei() const;
  inline void clear_imei();
  static const int kImeiFieldNumber = 2;
  inline const ::std::string& imei() const;
  inline void set_imei(const ::std::string& value);
  inline void set_imei(const char* value);
  inline void set_imei(const char* value, size_t size);
  inline ::std::string* mutable_imei();
  inline ::std::string* release_imei();
  inline void set_allocated_imei(::std::string* imei);

  // optional sint64 checkSum = 3;
  inline bool has_checksum() const;
  inline void clear_checksum();
  static const int kCheckSumFieldNumber = 3;
  inline ::google::protobuf::int64 checksum() const;
  inline void set_checksum(::google::protobuf::int64 value);

  // optional uint32 sign = 4;
  inline bool has_sign() const;
  inline void clear_sign();
  static const int kSignFieldNumber = 4;
  inline ::google::protobuf::uint32 sign() const;
  inline void set_sign(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.Head)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_imei();
  inline void clear_has_imei();
  inline void set_has_checksum();
  inline void clear_has_checksum();
  inline void set_has_sign();
  inline void clear_has_sign();

  ::std::string* uid_;
  ::std::string* imei_;
  ::google::protobuf::int64 checksum_;
  ::google::protobuf::uint32 sign_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_HSMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_HSMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_HSMessage_2eproto();
  friend void protobuf_ShutdownFile_HSMessage_2eproto();

  void InitAsDefaultInstance();
  static Head* default_instance_;
};
// -------------------------------------------------------------------

class Body : public ::google::protobuf::MessageLite {
 public:
  Body();
  virtual ~Body();

  Body(const Body& from);

  inline Body& operator=(const Body& from) {
    CopyFrom(from);
    return *this;
  }

  static const Body& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Body* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Body* other);

  // implements Message ----------------------------------------------

  Body* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Body& from);
  void MergeFrom(const Body& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 commandId = 1;
  inline int commandid_size() const;
  inline void clear_commandid();
  static const int kCommandIdFieldNumber = 1;
  inline ::google::protobuf::uint32 commandid(int index) const;
  inline void set_commandid(int index, ::google::protobuf::uint32 value);
  inline void add_commandid(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      commandid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_commandid();

  // repeated bytes data = 2;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data(int index) const;
  inline ::std::string* mutable_data(int index);
  inline void set_data(int index, const ::std::string& value);
  inline void set_data(int index, const char* value);
  inline void set_data(int index, const void* value, size_t size);
  inline ::std::string* add_data();
  inline void add_data(const ::std::string& value);
  inline void add_data(const char* value);
  inline void add_data(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& data() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_data();

  // @@protoc_insertion_point(class_scope:message.Body)
 private:

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > commandid_;
  ::google::protobuf::RepeatedPtrField< ::std::string> data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_HSMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_HSMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_HSMessage_2eproto();
  friend void protobuf_ShutdownFile_HSMessage_2eproto();

  void InitAsDefaultInstance();
  static Body* default_instance_;
};
// ===================================================================


// ===================================================================

// MessageInfo

// required .message.Head head = 1;
inline bool MessageInfo::has_head() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageInfo::set_has_head() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageInfo::clear_has_head() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageInfo::clear_head() {
  if (head_ != NULL) head_->::message::Head::Clear();
  clear_has_head();
}
inline const ::message::Head& MessageInfo::head() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return head_ != NULL ? *head_ : *default_instance().head_;
#else
  return head_ != NULL ? *head_ : *default_instance_->head_;
#endif
}
inline ::message::Head* MessageInfo::mutable_head() {
  set_has_head();
  if (head_ == NULL) head_ = new ::message::Head;
  return head_;
}
inline ::message::Head* MessageInfo::release_head() {
  clear_has_head();
  ::message::Head* temp = head_;
  head_ = NULL;
  return temp;
}
inline void MessageInfo::set_allocated_head(::message::Head* head) {
  delete head_;
  head_ = head;
  if (head) {
    set_has_head();
  } else {
    clear_has_head();
  }
}

// required .message.Body body = 2;
inline bool MessageInfo::has_body() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageInfo::set_has_body() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageInfo::clear_has_body() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageInfo::clear_body() {
  if (body_ != NULL) body_->::message::Body::Clear();
  clear_has_body();
}
inline const ::message::Body& MessageInfo::body() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return body_ != NULL ? *body_ : *default_instance().body_;
#else
  return body_ != NULL ? *body_ : *default_instance_->body_;
#endif
}
inline ::message::Body* MessageInfo::mutable_body() {
  set_has_body();
  if (body_ == NULL) body_ = new ::message::Body;
  return body_;
}
inline ::message::Body* MessageInfo::release_body() {
  clear_has_body();
  ::message::Body* temp = body_;
  body_ = NULL;
  return temp;
}
inline void MessageInfo::set_allocated_body(::message::Body* body) {
  delete body_;
  body_ = body;
  if (body) {
    set_has_body();
  } else {
    clear_has_body();
  }
}

// -------------------------------------------------------------------

// Head

// optional string uid = 1;
inline bool Head::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Head::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Head::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Head::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& Head::uid() const {
  return *uid_;
}
inline void Head::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void Head::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void Head::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Head::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* Head::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Head::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string imei = 2;
inline bool Head::has_imei() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Head::set_has_imei() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Head::clear_has_imei() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Head::clear_imei() {
  if (imei_ != &::google::protobuf::internal::kEmptyString) {
    imei_->clear();
  }
  clear_has_imei();
}
inline const ::std::string& Head::imei() const {
  return *imei_;
}
inline void Head::set_imei(const ::std::string& value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
}
inline void Head::set_imei(const char* value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
}
inline void Head::set_imei(const char* value, size_t size) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Head::mutable_imei() {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  return imei_;
}
inline ::std::string* Head::release_imei() {
  clear_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = imei_;
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Head::set_allocated_imei(::std::string* imei) {
  if (imei_ != &::google::protobuf::internal::kEmptyString) {
    delete imei_;
  }
  if (imei) {
    set_has_imei();
    imei_ = imei;
  } else {
    clear_has_imei();
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sint64 checkSum = 3;
inline bool Head::has_checksum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Head::set_has_checksum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Head::clear_has_checksum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Head::clear_checksum() {
  checksum_ = GOOGLE_LONGLONG(0);
  clear_has_checksum();
}
inline ::google::protobuf::int64 Head::checksum() const {
  return checksum_;
}
inline void Head::set_checksum(::google::protobuf::int64 value) {
  set_has_checksum();
  checksum_ = value;
}

// optional uint32 sign = 4;
inline bool Head::has_sign() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Head::set_has_sign() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Head::clear_has_sign() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Head::clear_sign() {
  sign_ = 0u;
  clear_has_sign();
}
inline ::google::protobuf::uint32 Head::sign() const {
  return sign_;
}
inline void Head::set_sign(::google::protobuf::uint32 value) {
  set_has_sign();
  sign_ = value;
}

// -------------------------------------------------------------------

// Body

// repeated uint32 commandId = 1;
inline int Body::commandid_size() const {
  return commandid_.size();
}
inline void Body::clear_commandid() {
  commandid_.Clear();
}
inline ::google::protobuf::uint32 Body::commandid(int index) const {
  return commandid_.Get(index);
}
inline void Body::set_commandid(int index, ::google::protobuf::uint32 value) {
  commandid_.Set(index, value);
}
inline void Body::add_commandid(::google::protobuf::uint32 value) {
  commandid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Body::commandid() const {
  return commandid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Body::mutable_commandid() {
  return &commandid_;
}

// repeated bytes data = 2;
inline int Body::data_size() const {
  return data_.size();
}
inline void Body::clear_data() {
  data_.Clear();
}
inline const ::std::string& Body::data(int index) const {
  return data_.Get(index);
}
inline ::std::string* Body::mutable_data(int index) {
  return data_.Mutable(index);
}
inline void Body::set_data(int index, const ::std::string& value) {
  data_.Mutable(index)->assign(value);
}
inline void Body::set_data(int index, const char* value) {
  data_.Mutable(index)->assign(value);
}
inline void Body::set_data(int index, const void* value, size_t size) {
  data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Body::add_data() {
  return data_.Add();
}
inline void Body::add_data(const ::std::string& value) {
  data_.Add()->assign(value);
}
inline void Body::add_data(const char* value) {
  data_.Add()->assign(value);
}
inline void Body::add_data(const void* value, size_t size) {
  data_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Body::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Body::mutable_data() {
  return &data_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace message

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_HSMessage_2eproto__INCLUDED
