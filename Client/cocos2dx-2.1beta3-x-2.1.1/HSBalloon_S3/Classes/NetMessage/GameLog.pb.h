// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GameLog.proto

#ifndef PROTOBUF_GameLog_2eproto__INCLUDED
#define PROTOBUF_GameLog_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace message {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_GameLog_2eproto();
void protobuf_AssignDesc_GameLog_2eproto();
void protobuf_ShutdownFile_GameLog_2eproto();

class LogRequest;
class LogRequest_UserLog;
class LogRequest_TerminalLog;
class LogRequest_GoodsLog;
class LogResponse;

enum LogRequest_ActionType {
  LogRequest_ActionType_Normal = -1,
  LogRequest_ActionType_Activate = 0,
  LogRequest_ActionType_Register = 1,
  LogRequest_ActionType_Login = 2,
  LogRequest_ActionType_Logout = 3,
  LogRequest_ActionType_Logoff = 4
};
bool LogRequest_ActionType_IsValid(int value);
const LogRequest_ActionType LogRequest_ActionType_ActionType_MIN = LogRequest_ActionType_Normal;
const LogRequest_ActionType LogRequest_ActionType_ActionType_MAX = LogRequest_ActionType_Logoff;
const int LogRequest_ActionType_ActionType_ARRAYSIZE = LogRequest_ActionType_ActionType_MAX + 1;

enum LogRequest_BuyType {
  LogRequest_BuyType_BuyItem = 1,
  LogRequest_BuyType_BuyGold = 2,
  LogRequest_BuyType_BuyGood = 3,
  LogRequest_BuyType_BuyOrnament = 4
};
bool LogRequest_BuyType_IsValid(int value);
const LogRequest_BuyType LogRequest_BuyType_BuyType_MIN = LogRequest_BuyType_BuyItem;
const LogRequest_BuyType LogRequest_BuyType_BuyType_MAX = LogRequest_BuyType_BuyOrnament;
const int LogRequest_BuyType_BuyType_ARRAYSIZE = LogRequest_BuyType_BuyType_MAX + 1;

enum LogRequest_BuyState {
  LogRequest_BuyState_Success = 0,
  LogRequest_BuyState_Fail = 1,
  LogRequest_BuyState_Repeat_Buy = 2
};
bool LogRequest_BuyState_IsValid(int value);
const LogRequest_BuyState LogRequest_BuyState_BuyState_MIN = LogRequest_BuyState_Success;
const LogRequest_BuyState LogRequest_BuyState_BuyState_MAX = LogRequest_BuyState_Repeat_Buy;
const int LogRequest_BuyState_BuyState_ARRAYSIZE = LogRequest_BuyState_BuyState_MAX + 1;

enum LogResponse_ResultStatus {
  LogResponse_ResultStatus_OK = 1,
  LogResponse_ResultStatus_FAIL = 0
};
bool LogResponse_ResultStatus_IsValid(int value);
const LogResponse_ResultStatus LogResponse_ResultStatus_ResultStatus_MIN = LogResponse_ResultStatus_FAIL;
const LogResponse_ResultStatus LogResponse_ResultStatus_ResultStatus_MAX = LogResponse_ResultStatus_OK;
const int LogResponse_ResultStatus_ResultStatus_ARRAYSIZE = LogResponse_ResultStatus_ResultStatus_MAX + 1;

// ===================================================================

class LogRequest_UserLog : public ::google::protobuf::MessageLite {
 public:
  LogRequest_UserLog();
  virtual ~LogRequest_UserLog();

  LogRequest_UserLog(const LogRequest_UserLog& from);

  inline LogRequest_UserLog& operator=(const LogRequest_UserLog& from) {
    CopyFrom(from);
    return *this;
  }

  static const LogRequest_UserLog& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LogRequest_UserLog* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LogRequest_UserLog* other);

  // implements Message ----------------------------------------------

  LogRequest_UserLog* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LogRequest_UserLog& from);
  void MergeFrom(const LogRequest_UserLog& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 chID = 1;
  inline bool has_chid() const;
  inline void clear_chid();
  static const int kChIDFieldNumber = 1;
  inline ::google::protobuf::int32 chid() const;
  inline void set_chid(::google::protobuf::int32 value);

  // optional uint64 loginTime = 2;
  inline bool has_logintime() const;
  inline void clear_logintime();
  static const int kLoginTimeFieldNumber = 2;
  inline ::google::protobuf::uint64 logintime() const;
  inline void set_logintime(::google::protobuf::uint64 value);

  // optional .message.LogRequest.ActionType actionType = 3;
  inline bool has_actiontype() const;
  inline void clear_actiontype();
  static const int kActionTypeFieldNumber = 3;
  inline ::message::LogRequest_ActionType actiontype() const;
  inline void set_actiontype(::message::LogRequest_ActionType value);

  // optional uint64 logoutTime = 4;
  inline bool has_logouttime() const;
  inline void clear_logouttime();
  static const int kLogoutTimeFieldNumber = 4;
  inline ::google::protobuf::uint64 logouttime() const;
  inline void set_logouttime(::google::protobuf::uint64 value);

  // optional uint64 sTime = 5;
  inline bool has_stime() const;
  inline void clear_stime();
  static const int kSTimeFieldNumber = 5;
  inline ::google::protobuf::uint64 stime() const;
  inline void set_stime(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:message.LogRequest.UserLog)
 private:
  inline void set_has_chid();
  inline void clear_has_chid();
  inline void set_has_logintime();
  inline void clear_has_logintime();
  inline void set_has_actiontype();
  inline void clear_has_actiontype();
  inline void set_has_logouttime();
  inline void clear_has_logouttime();
  inline void set_has_stime();
  inline void clear_has_stime();

  ::google::protobuf::uint64 logintime_;
  ::google::protobuf::int32 chid_;
  int actiontype_;
  ::google::protobuf::uint64 logouttime_;
  ::google::protobuf::uint64 stime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameLog_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameLog_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameLog_2eproto();
  friend void protobuf_ShutdownFile_GameLog_2eproto();

  void InitAsDefaultInstance();
  static LogRequest_UserLog* default_instance_;
};
// -------------------------------------------------------------------

class LogRequest_TerminalLog : public ::google::protobuf::MessageLite {
 public:
  LogRequest_TerminalLog();
  virtual ~LogRequest_TerminalLog();

  LogRequest_TerminalLog(const LogRequest_TerminalLog& from);

  inline LogRequest_TerminalLog& operator=(const LogRequest_TerminalLog& from) {
    CopyFrom(from);
    return *this;
  }

  static const LogRequest_TerminalLog& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LogRequest_TerminalLog* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LogRequest_TerminalLog* other);

  // implements Message ----------------------------------------------

  LogRequest_TerminalLog* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LogRequest_TerminalLog& from);
  void MergeFrom(const LogRequest_TerminalLog& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string osName = 1;
  inline bool has_osname() const;
  inline void clear_osname();
  static const int kOsNameFieldNumber = 1;
  inline const ::std::string& osname() const;
  inline void set_osname(const ::std::string& value);
  inline void set_osname(const char* value);
  inline void set_osname(const char* value, size_t size);
  inline ::std::string* mutable_osname();
  inline ::std::string* release_osname();
  inline void set_allocated_osname(::std::string* osname);

  // optional string dpiSize = 2;
  inline bool has_dpisize() const;
  inline void clear_dpisize();
  static const int kDpiSizeFieldNumber = 2;
  inline const ::std::string& dpisize() const;
  inline void set_dpisize(const ::std::string& value);
  inline void set_dpisize(const char* value);
  inline void set_dpisize(const char* value, size_t size);
  inline ::std::string* mutable_dpisize();
  inline ::std::string* release_dpisize();
  inline void set_allocated_dpisize(::std::string* dpisize);

  // optional string cliType = 3;
  inline bool has_clitype() const;
  inline void clear_clitype();
  static const int kCliTypeFieldNumber = 3;
  inline const ::std::string& clitype() const;
  inline void set_clitype(const ::std::string& value);
  inline void set_clitype(const char* value);
  inline void set_clitype(const char* value, size_t size);
  inline ::std::string* mutable_clitype();
  inline ::std::string* release_clitype();
  inline void set_allocated_clitype(::std::string* clitype);

  // optional string verInfo = 4;
  inline bool has_verinfo() const;
  inline void clear_verinfo();
  static const int kVerInfoFieldNumber = 4;
  inline const ::std::string& verinfo() const;
  inline void set_verinfo(const ::std::string& value);
  inline void set_verinfo(const char* value);
  inline void set_verinfo(const char* value, size_t size);
  inline ::std::string* mutable_verinfo();
  inline ::std::string* release_verinfo();
  inline void set_allocated_verinfo(::std::string* verinfo);

  // optional string netType = 5;
  inline bool has_nettype() const;
  inline void clear_nettype();
  static const int kNetTypeFieldNumber = 5;
  inline const ::std::string& nettype() const;
  inline void set_nettype(const ::std::string& value);
  inline void set_nettype(const char* value);
  inline void set_nettype(const char* value, size_t size);
  inline ::std::string* mutable_nettype();
  inline ::std::string* release_nettype();
  inline void set_allocated_nettype(::std::string* nettype);

  // optional string netProInfo = 6;
  inline bool has_netproinfo() const;
  inline void clear_netproinfo();
  static const int kNetProInfoFieldNumber = 6;
  inline const ::std::string& netproinfo() const;
  inline void set_netproinfo(const ::std::string& value);
  inline void set_netproinfo(const char* value);
  inline void set_netproinfo(const char* value, size_t size);
  inline ::std::string* mutable_netproinfo();
  inline ::std::string* release_netproinfo();
  inline void set_allocated_netproinfo(::std::string* netproinfo);

  // optional string countryInfo = 7;
  inline bool has_countryinfo() const;
  inline void clear_countryinfo();
  static const int kCountryInfoFieldNumber = 7;
  inline const ::std::string& countryinfo() const;
  inline void set_countryinfo(const ::std::string& value);
  inline void set_countryinfo(const char* value);
  inline void set_countryinfo(const char* value, size_t size);
  inline ::std::string* mutable_countryinfo();
  inline ::std::string* release_countryinfo();
  inline void set_allocated_countryinfo(::std::string* countryinfo);

  // optional string cityInfo = 8;
  inline bool has_cityinfo() const;
  inline void clear_cityinfo();
  static const int kCityInfoFieldNumber = 8;
  inline const ::std::string& cityinfo() const;
  inline void set_cityinfo(const ::std::string& value);
  inline void set_cityinfo(const char* value);
  inline void set_cityinfo(const char* value, size_t size);
  inline ::std::string* mutable_cityinfo();
  inline ::std::string* release_cityinfo();
  inline void set_allocated_cityinfo(::std::string* cityinfo);

  // @@protoc_insertion_point(class_scope:message.LogRequest.TerminalLog)
 private:
  inline void set_has_osname();
  inline void clear_has_osname();
  inline void set_has_dpisize();
  inline void clear_has_dpisize();
  inline void set_has_clitype();
  inline void clear_has_clitype();
  inline void set_has_verinfo();
  inline void clear_has_verinfo();
  inline void set_has_nettype();
  inline void clear_has_nettype();
  inline void set_has_netproinfo();
  inline void clear_has_netproinfo();
  inline void set_has_countryinfo();
  inline void clear_has_countryinfo();
  inline void set_has_cityinfo();
  inline void clear_has_cityinfo();

  ::std::string* osname_;
  ::std::string* dpisize_;
  ::std::string* clitype_;
  ::std::string* verinfo_;
  ::std::string* nettype_;
  ::std::string* netproinfo_;
  ::std::string* countryinfo_;
  ::std::string* cityinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameLog_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameLog_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameLog_2eproto();
  friend void protobuf_ShutdownFile_GameLog_2eproto();

  void InitAsDefaultInstance();
  static LogRequest_TerminalLog* default_instance_;
};
// -------------------------------------------------------------------

class LogRequest_GoodsLog : public ::google::protobuf::MessageLite {
 public:
  LogRequest_GoodsLog();
  virtual ~LogRequest_GoodsLog();

  LogRequest_GoodsLog(const LogRequest_GoodsLog& from);

  inline LogRequest_GoodsLog& operator=(const LogRequest_GoodsLog& from) {
    CopyFrom(from);
    return *this;
  }

  static const LogRequest_GoodsLog& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LogRequest_GoodsLog* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LogRequest_GoodsLog* other);

  // implements Message ----------------------------------------------

  LogRequest_GoodsLog* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LogRequest_GoodsLog& from);
  void MergeFrom(const LogRequest_GoodsLog& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 chID = 1;
  inline bool has_chid() const;
  inline void clear_chid();
  static const int kChIDFieldNumber = 1;
  inline ::google::protobuf::int32 chid() const;
  inline void set_chid(::google::protobuf::int32 value);

  // optional .message.LogRequest.BuyType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::message::LogRequest_BuyType type() const;
  inline void set_type(::message::LogRequest_BuyType value);

  // optional int32 goodsID = 3;
  inline bool has_goodsid() const;
  inline void clear_goodsid();
  static const int kGoodsIDFieldNumber = 3;
  inline ::google::protobuf::int32 goodsid() const;
  inline void set_goodsid(::google::protobuf::int32 value);

  // optional int32 buySize = 4;
  inline bool has_buysize() const;
  inline void clear_buysize();
  static const int kBuySizeFieldNumber = 4;
  inline ::google::protobuf::int32 buysize() const;
  inline void set_buysize(::google::protobuf::int32 value);

  // optional .message.LogRequest.BuyState state = 5;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 5;
  inline ::message::LogRequest_BuyState state() const;
  inline void set_state(::message::LogRequest_BuyState value);

  // optional uint64 buyTime = 6;
  inline bool has_buytime() const;
  inline void clear_buytime();
  static const int kBuyTimeFieldNumber = 6;
  inline ::google::protobuf::uint64 buytime() const;
  inline void set_buytime(::google::protobuf::uint64 value);

  // optional uint64 sTime = 7;
  inline bool has_stime() const;
  inline void clear_stime();
  static const int kSTimeFieldNumber = 7;
  inline ::google::protobuf::uint64 stime() const;
  inline void set_stime(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:message.LogRequest.GoodsLog)
 private:
  inline void set_has_chid();
  inline void clear_has_chid();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_goodsid();
  inline void clear_has_goodsid();
  inline void set_has_buysize();
  inline void clear_has_buysize();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_buytime();
  inline void clear_has_buytime();
  inline void set_has_stime();
  inline void clear_has_stime();

  ::google::protobuf::int32 chid_;
  int type_;
  ::google::protobuf::int32 goodsid_;
  ::google::protobuf::int32 buysize_;
  ::google::protobuf::uint64 buytime_;
  ::google::protobuf::uint64 stime_;
  int state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameLog_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameLog_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameLog_2eproto();
  friend void protobuf_ShutdownFile_GameLog_2eproto();

  void InitAsDefaultInstance();
  static LogRequest_GoodsLog* default_instance_;
};
// -------------------------------------------------------------------

class LogRequest : public ::google::protobuf::MessageLite {
 public:
  LogRequest();
  virtual ~LogRequest();

  LogRequest(const LogRequest& from);

  inline LogRequest& operator=(const LogRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const LogRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LogRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LogRequest* other);

  // implements Message ----------------------------------------------

  LogRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LogRequest& from);
  void MergeFrom(const LogRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef LogRequest_UserLog UserLog;
  typedef LogRequest_TerminalLog TerminalLog;
  typedef LogRequest_GoodsLog GoodsLog;

  typedef LogRequest_ActionType ActionType;
  static const ActionType Normal = LogRequest_ActionType_Normal;
  static const ActionType Activate = LogRequest_ActionType_Activate;
  static const ActionType Register = LogRequest_ActionType_Register;
  static const ActionType Login = LogRequest_ActionType_Login;
  static const ActionType Logout = LogRequest_ActionType_Logout;
  static const ActionType Logoff = LogRequest_ActionType_Logoff;
  static inline bool ActionType_IsValid(int value) {
    return LogRequest_ActionType_IsValid(value);
  }
  static const ActionType ActionType_MIN =
    LogRequest_ActionType_ActionType_MIN;
  static const ActionType ActionType_MAX =
    LogRequest_ActionType_ActionType_MAX;
  static const int ActionType_ARRAYSIZE =
    LogRequest_ActionType_ActionType_ARRAYSIZE;

  typedef LogRequest_BuyType BuyType;
  static const BuyType BuyItem = LogRequest_BuyType_BuyItem;
  static const BuyType BuyGold = LogRequest_BuyType_BuyGold;
  static const BuyType BuyGood = LogRequest_BuyType_BuyGood;
  static const BuyType BuyOrnament = LogRequest_BuyType_BuyOrnament;
  static inline bool BuyType_IsValid(int value) {
    return LogRequest_BuyType_IsValid(value);
  }
  static const BuyType BuyType_MIN =
    LogRequest_BuyType_BuyType_MIN;
  static const BuyType BuyType_MAX =
    LogRequest_BuyType_BuyType_MAX;
  static const int BuyType_ARRAYSIZE =
    LogRequest_BuyType_BuyType_ARRAYSIZE;

  typedef LogRequest_BuyState BuyState;
  static const BuyState Success = LogRequest_BuyState_Success;
  static const BuyState Fail = LogRequest_BuyState_Fail;
  static const BuyState Repeat_Buy = LogRequest_BuyState_Repeat_Buy;
  static inline bool BuyState_IsValid(int value) {
    return LogRequest_BuyState_IsValid(value);
  }
  static const BuyState BuyState_MIN =
    LogRequest_BuyState_BuyState_MIN;
  static const BuyState BuyState_MAX =
    LogRequest_BuyState_BuyState_MAX;
  static const int BuyState_ARRAYSIZE =
    LogRequest_BuyState_BuyState_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .message.LogRequest.UserLog userLogs = 1;
  inline int userlogs_size() const;
  inline void clear_userlogs();
  static const int kUserLogsFieldNumber = 1;
  inline const ::message::LogRequest_UserLog& userlogs(int index) const;
  inline ::message::LogRequest_UserLog* mutable_userlogs(int index);
  inline ::message::LogRequest_UserLog* add_userlogs();
  inline const ::google::protobuf::RepeatedPtrField< ::message::LogRequest_UserLog >&
      userlogs() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::LogRequest_UserLog >*
      mutable_userlogs();

  // optional .message.LogRequest.TerminalLog terminalLogs = 2;
  inline bool has_terminallogs() const;
  inline void clear_terminallogs();
  static const int kTerminalLogsFieldNumber = 2;
  inline const ::message::LogRequest_TerminalLog& terminallogs() const;
  inline ::message::LogRequest_TerminalLog* mutable_terminallogs();
  inline ::message::LogRequest_TerminalLog* release_terminallogs();
  inline void set_allocated_terminallogs(::message::LogRequest_TerminalLog* terminallogs);

  // repeated .message.LogRequest.GoodsLog goodsLog = 3;
  inline int goodslog_size() const;
  inline void clear_goodslog();
  static const int kGoodsLogFieldNumber = 3;
  inline const ::message::LogRequest_GoodsLog& goodslog(int index) const;
  inline ::message::LogRequest_GoodsLog* mutable_goodslog(int index);
  inline ::message::LogRequest_GoodsLog* add_goodslog();
  inline const ::google::protobuf::RepeatedPtrField< ::message::LogRequest_GoodsLog >&
      goodslog() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::LogRequest_GoodsLog >*
      mutable_goodslog();

  // @@protoc_insertion_point(class_scope:message.LogRequest)
 private:
  inline void set_has_terminallogs();
  inline void clear_has_terminallogs();

  ::google::protobuf::RepeatedPtrField< ::message::LogRequest_UserLog > userlogs_;
  ::message::LogRequest_TerminalLog* terminallogs_;
  ::google::protobuf::RepeatedPtrField< ::message::LogRequest_GoodsLog > goodslog_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameLog_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameLog_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameLog_2eproto();
  friend void protobuf_ShutdownFile_GameLog_2eproto();

  void InitAsDefaultInstance();
  static LogRequest* default_instance_;
};
// -------------------------------------------------------------------

class LogResponse : public ::google::protobuf::MessageLite {
 public:
  LogResponse();
  virtual ~LogResponse();

  LogResponse(const LogResponse& from);

  inline LogResponse& operator=(const LogResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const LogResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LogResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LogResponse* other);

  // implements Message ----------------------------------------------

  LogResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LogResponse& from);
  void MergeFrom(const LogResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef LogResponse_ResultStatus ResultStatus;
  static const ResultStatus OK = LogResponse_ResultStatus_OK;
  static const ResultStatus FAIL = LogResponse_ResultStatus_FAIL;
  static inline bool ResultStatus_IsValid(int value) {
    return LogResponse_ResultStatus_IsValid(value);
  }
  static const ResultStatus ResultStatus_MIN =
    LogResponse_ResultStatus_ResultStatus_MIN;
  static const ResultStatus ResultStatus_MAX =
    LogResponse_ResultStatus_ResultStatus_MAX;
  static const int ResultStatus_ARRAYSIZE =
    LogResponse_ResultStatus_ResultStatus_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .message.LogResponse.ResultStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::message::LogResponse_ResultStatus status() const;
  inline void set_status(::message::LogResponse_ResultStatus value);

  // @@protoc_insertion_point(class_scope:message.LogResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameLog_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameLog_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameLog_2eproto();
  friend void protobuf_ShutdownFile_GameLog_2eproto();

  void InitAsDefaultInstance();
  static LogResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// LogRequest_UserLog

// optional int32 chID = 1;
inline bool LogRequest_UserLog::has_chid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogRequest_UserLog::set_has_chid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogRequest_UserLog::clear_has_chid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogRequest_UserLog::clear_chid() {
  chid_ = 0;
  clear_has_chid();
}
inline ::google::protobuf::int32 LogRequest_UserLog::chid() const {
  return chid_;
}
inline void LogRequest_UserLog::set_chid(::google::protobuf::int32 value) {
  set_has_chid();
  chid_ = value;
}

// optional uint64 loginTime = 2;
inline bool LogRequest_UserLog::has_logintime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogRequest_UserLog::set_has_logintime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogRequest_UserLog::clear_has_logintime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogRequest_UserLog::clear_logintime() {
  logintime_ = GOOGLE_ULONGLONG(0);
  clear_has_logintime();
}
inline ::google::protobuf::uint64 LogRequest_UserLog::logintime() const {
  return logintime_;
}
inline void LogRequest_UserLog::set_logintime(::google::protobuf::uint64 value) {
  set_has_logintime();
  logintime_ = value;
}

// optional .message.LogRequest.ActionType actionType = 3;
inline bool LogRequest_UserLog::has_actiontype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogRequest_UserLog::set_has_actiontype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LogRequest_UserLog::clear_has_actiontype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LogRequest_UserLog::clear_actiontype() {
  actiontype_ = -1;
  clear_has_actiontype();
}
inline ::message::LogRequest_ActionType LogRequest_UserLog::actiontype() const {
  return static_cast< ::message::LogRequest_ActionType >(actiontype_);
}
inline void LogRequest_UserLog::set_actiontype(::message::LogRequest_ActionType value) {
  assert(::message::LogRequest_ActionType_IsValid(value));
  set_has_actiontype();
  actiontype_ = value;
}

// optional uint64 logoutTime = 4;
inline bool LogRequest_UserLog::has_logouttime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LogRequest_UserLog::set_has_logouttime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LogRequest_UserLog::clear_has_logouttime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LogRequest_UserLog::clear_logouttime() {
  logouttime_ = GOOGLE_ULONGLONG(0);
  clear_has_logouttime();
}
inline ::google::protobuf::uint64 LogRequest_UserLog::logouttime() const {
  return logouttime_;
}
inline void LogRequest_UserLog::set_logouttime(::google::protobuf::uint64 value) {
  set_has_logouttime();
  logouttime_ = value;
}

// optional uint64 sTime = 5;
inline bool LogRequest_UserLog::has_stime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LogRequest_UserLog::set_has_stime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LogRequest_UserLog::clear_has_stime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LogRequest_UserLog::clear_stime() {
  stime_ = GOOGLE_ULONGLONG(0);
  clear_has_stime();
}
inline ::google::protobuf::uint64 LogRequest_UserLog::stime() const {
  return stime_;
}
inline void LogRequest_UserLog::set_stime(::google::protobuf::uint64 value) {
  set_has_stime();
  stime_ = value;
}

// -------------------------------------------------------------------

// LogRequest_TerminalLog

// optional string osName = 1;
inline bool LogRequest_TerminalLog::has_osname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogRequest_TerminalLog::set_has_osname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogRequest_TerminalLog::clear_has_osname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogRequest_TerminalLog::clear_osname() {
  if (osname_ != &::google::protobuf::internal::kEmptyString) {
    osname_->clear();
  }
  clear_has_osname();
}
inline const ::std::string& LogRequest_TerminalLog::osname() const {
  return *osname_;
}
inline void LogRequest_TerminalLog::set_osname(const ::std::string& value) {
  set_has_osname();
  if (osname_ == &::google::protobuf::internal::kEmptyString) {
    osname_ = new ::std::string;
  }
  osname_->assign(value);
}
inline void LogRequest_TerminalLog::set_osname(const char* value) {
  set_has_osname();
  if (osname_ == &::google::protobuf::internal::kEmptyString) {
    osname_ = new ::std::string;
  }
  osname_->assign(value);
}
inline void LogRequest_TerminalLog::set_osname(const char* value, size_t size) {
  set_has_osname();
  if (osname_ == &::google::protobuf::internal::kEmptyString) {
    osname_ = new ::std::string;
  }
  osname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogRequest_TerminalLog::mutable_osname() {
  set_has_osname();
  if (osname_ == &::google::protobuf::internal::kEmptyString) {
    osname_ = new ::std::string;
  }
  return osname_;
}
inline ::std::string* LogRequest_TerminalLog::release_osname() {
  clear_has_osname();
  if (osname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = osname_;
    osname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LogRequest_TerminalLog::set_allocated_osname(::std::string* osname) {
  if (osname_ != &::google::protobuf::internal::kEmptyString) {
    delete osname_;
  }
  if (osname) {
    set_has_osname();
    osname_ = osname;
  } else {
    clear_has_osname();
    osname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string dpiSize = 2;
inline bool LogRequest_TerminalLog::has_dpisize() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogRequest_TerminalLog::set_has_dpisize() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogRequest_TerminalLog::clear_has_dpisize() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogRequest_TerminalLog::clear_dpisize() {
  if (dpisize_ != &::google::protobuf::internal::kEmptyString) {
    dpisize_->clear();
  }
  clear_has_dpisize();
}
inline const ::std::string& LogRequest_TerminalLog::dpisize() const {
  return *dpisize_;
}
inline void LogRequest_TerminalLog::set_dpisize(const ::std::string& value) {
  set_has_dpisize();
  if (dpisize_ == &::google::protobuf::internal::kEmptyString) {
    dpisize_ = new ::std::string;
  }
  dpisize_->assign(value);
}
inline void LogRequest_TerminalLog::set_dpisize(const char* value) {
  set_has_dpisize();
  if (dpisize_ == &::google::protobuf::internal::kEmptyString) {
    dpisize_ = new ::std::string;
  }
  dpisize_->assign(value);
}
inline void LogRequest_TerminalLog::set_dpisize(const char* value, size_t size) {
  set_has_dpisize();
  if (dpisize_ == &::google::protobuf::internal::kEmptyString) {
    dpisize_ = new ::std::string;
  }
  dpisize_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogRequest_TerminalLog::mutable_dpisize() {
  set_has_dpisize();
  if (dpisize_ == &::google::protobuf::internal::kEmptyString) {
    dpisize_ = new ::std::string;
  }
  return dpisize_;
}
inline ::std::string* LogRequest_TerminalLog::release_dpisize() {
  clear_has_dpisize();
  if (dpisize_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dpisize_;
    dpisize_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LogRequest_TerminalLog::set_allocated_dpisize(::std::string* dpisize) {
  if (dpisize_ != &::google::protobuf::internal::kEmptyString) {
    delete dpisize_;
  }
  if (dpisize) {
    set_has_dpisize();
    dpisize_ = dpisize;
  } else {
    clear_has_dpisize();
    dpisize_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string cliType = 3;
inline bool LogRequest_TerminalLog::has_clitype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogRequest_TerminalLog::set_has_clitype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LogRequest_TerminalLog::clear_has_clitype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LogRequest_TerminalLog::clear_clitype() {
  if (clitype_ != &::google::protobuf::internal::kEmptyString) {
    clitype_->clear();
  }
  clear_has_clitype();
}
inline const ::std::string& LogRequest_TerminalLog::clitype() const {
  return *clitype_;
}
inline void LogRequest_TerminalLog::set_clitype(const ::std::string& value) {
  set_has_clitype();
  if (clitype_ == &::google::protobuf::internal::kEmptyString) {
    clitype_ = new ::std::string;
  }
  clitype_->assign(value);
}
inline void LogRequest_TerminalLog::set_clitype(const char* value) {
  set_has_clitype();
  if (clitype_ == &::google::protobuf::internal::kEmptyString) {
    clitype_ = new ::std::string;
  }
  clitype_->assign(value);
}
inline void LogRequest_TerminalLog::set_clitype(const char* value, size_t size) {
  set_has_clitype();
  if (clitype_ == &::google::protobuf::internal::kEmptyString) {
    clitype_ = new ::std::string;
  }
  clitype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogRequest_TerminalLog::mutable_clitype() {
  set_has_clitype();
  if (clitype_ == &::google::protobuf::internal::kEmptyString) {
    clitype_ = new ::std::string;
  }
  return clitype_;
}
inline ::std::string* LogRequest_TerminalLog::release_clitype() {
  clear_has_clitype();
  if (clitype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clitype_;
    clitype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LogRequest_TerminalLog::set_allocated_clitype(::std::string* clitype) {
  if (clitype_ != &::google::protobuf::internal::kEmptyString) {
    delete clitype_;
  }
  if (clitype) {
    set_has_clitype();
    clitype_ = clitype;
  } else {
    clear_has_clitype();
    clitype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string verInfo = 4;
inline bool LogRequest_TerminalLog::has_verinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LogRequest_TerminalLog::set_has_verinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LogRequest_TerminalLog::clear_has_verinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LogRequest_TerminalLog::clear_verinfo() {
  if (verinfo_ != &::google::protobuf::internal::kEmptyString) {
    verinfo_->clear();
  }
  clear_has_verinfo();
}
inline const ::std::string& LogRequest_TerminalLog::verinfo() const {
  return *verinfo_;
}
inline void LogRequest_TerminalLog::set_verinfo(const ::std::string& value) {
  set_has_verinfo();
  if (verinfo_ == &::google::protobuf::internal::kEmptyString) {
    verinfo_ = new ::std::string;
  }
  verinfo_->assign(value);
}
inline void LogRequest_TerminalLog::set_verinfo(const char* value) {
  set_has_verinfo();
  if (verinfo_ == &::google::protobuf::internal::kEmptyString) {
    verinfo_ = new ::std::string;
  }
  verinfo_->assign(value);
}
inline void LogRequest_TerminalLog::set_verinfo(const char* value, size_t size) {
  set_has_verinfo();
  if (verinfo_ == &::google::protobuf::internal::kEmptyString) {
    verinfo_ = new ::std::string;
  }
  verinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogRequest_TerminalLog::mutable_verinfo() {
  set_has_verinfo();
  if (verinfo_ == &::google::protobuf::internal::kEmptyString) {
    verinfo_ = new ::std::string;
  }
  return verinfo_;
}
inline ::std::string* LogRequest_TerminalLog::release_verinfo() {
  clear_has_verinfo();
  if (verinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = verinfo_;
    verinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LogRequest_TerminalLog::set_allocated_verinfo(::std::string* verinfo) {
  if (verinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete verinfo_;
  }
  if (verinfo) {
    set_has_verinfo();
    verinfo_ = verinfo;
  } else {
    clear_has_verinfo();
    verinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string netType = 5;
inline bool LogRequest_TerminalLog::has_nettype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LogRequest_TerminalLog::set_has_nettype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LogRequest_TerminalLog::clear_has_nettype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LogRequest_TerminalLog::clear_nettype() {
  if (nettype_ != &::google::protobuf::internal::kEmptyString) {
    nettype_->clear();
  }
  clear_has_nettype();
}
inline const ::std::string& LogRequest_TerminalLog::nettype() const {
  return *nettype_;
}
inline void LogRequest_TerminalLog::set_nettype(const ::std::string& value) {
  set_has_nettype();
  if (nettype_ == &::google::protobuf::internal::kEmptyString) {
    nettype_ = new ::std::string;
  }
  nettype_->assign(value);
}
inline void LogRequest_TerminalLog::set_nettype(const char* value) {
  set_has_nettype();
  if (nettype_ == &::google::protobuf::internal::kEmptyString) {
    nettype_ = new ::std::string;
  }
  nettype_->assign(value);
}
inline void LogRequest_TerminalLog::set_nettype(const char* value, size_t size) {
  set_has_nettype();
  if (nettype_ == &::google::protobuf::internal::kEmptyString) {
    nettype_ = new ::std::string;
  }
  nettype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogRequest_TerminalLog::mutable_nettype() {
  set_has_nettype();
  if (nettype_ == &::google::protobuf::internal::kEmptyString) {
    nettype_ = new ::std::string;
  }
  return nettype_;
}
inline ::std::string* LogRequest_TerminalLog::release_nettype() {
  clear_has_nettype();
  if (nettype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nettype_;
    nettype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LogRequest_TerminalLog::set_allocated_nettype(::std::string* nettype) {
  if (nettype_ != &::google::protobuf::internal::kEmptyString) {
    delete nettype_;
  }
  if (nettype) {
    set_has_nettype();
    nettype_ = nettype;
  } else {
    clear_has_nettype();
    nettype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string netProInfo = 6;
inline bool LogRequest_TerminalLog::has_netproinfo() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LogRequest_TerminalLog::set_has_netproinfo() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LogRequest_TerminalLog::clear_has_netproinfo() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LogRequest_TerminalLog::clear_netproinfo() {
  if (netproinfo_ != &::google::protobuf::internal::kEmptyString) {
    netproinfo_->clear();
  }
  clear_has_netproinfo();
}
inline const ::std::string& LogRequest_TerminalLog::netproinfo() const {
  return *netproinfo_;
}
inline void LogRequest_TerminalLog::set_netproinfo(const ::std::string& value) {
  set_has_netproinfo();
  if (netproinfo_ == &::google::protobuf::internal::kEmptyString) {
    netproinfo_ = new ::std::string;
  }
  netproinfo_->assign(value);
}
inline void LogRequest_TerminalLog::set_netproinfo(const char* value) {
  set_has_netproinfo();
  if (netproinfo_ == &::google::protobuf::internal::kEmptyString) {
    netproinfo_ = new ::std::string;
  }
  netproinfo_->assign(value);
}
inline void LogRequest_TerminalLog::set_netproinfo(const char* value, size_t size) {
  set_has_netproinfo();
  if (netproinfo_ == &::google::protobuf::internal::kEmptyString) {
    netproinfo_ = new ::std::string;
  }
  netproinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogRequest_TerminalLog::mutable_netproinfo() {
  set_has_netproinfo();
  if (netproinfo_ == &::google::protobuf::internal::kEmptyString) {
    netproinfo_ = new ::std::string;
  }
  return netproinfo_;
}
inline ::std::string* LogRequest_TerminalLog::release_netproinfo() {
  clear_has_netproinfo();
  if (netproinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = netproinfo_;
    netproinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LogRequest_TerminalLog::set_allocated_netproinfo(::std::string* netproinfo) {
  if (netproinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete netproinfo_;
  }
  if (netproinfo) {
    set_has_netproinfo();
    netproinfo_ = netproinfo;
  } else {
    clear_has_netproinfo();
    netproinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string countryInfo = 7;
inline bool LogRequest_TerminalLog::has_countryinfo() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LogRequest_TerminalLog::set_has_countryinfo() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LogRequest_TerminalLog::clear_has_countryinfo() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LogRequest_TerminalLog::clear_countryinfo() {
  if (countryinfo_ != &::google::protobuf::internal::kEmptyString) {
    countryinfo_->clear();
  }
  clear_has_countryinfo();
}
inline const ::std::string& LogRequest_TerminalLog::countryinfo() const {
  return *countryinfo_;
}
inline void LogRequest_TerminalLog::set_countryinfo(const ::std::string& value) {
  set_has_countryinfo();
  if (countryinfo_ == &::google::protobuf::internal::kEmptyString) {
    countryinfo_ = new ::std::string;
  }
  countryinfo_->assign(value);
}
inline void LogRequest_TerminalLog::set_countryinfo(const char* value) {
  set_has_countryinfo();
  if (countryinfo_ == &::google::protobuf::internal::kEmptyString) {
    countryinfo_ = new ::std::string;
  }
  countryinfo_->assign(value);
}
inline void LogRequest_TerminalLog::set_countryinfo(const char* value, size_t size) {
  set_has_countryinfo();
  if (countryinfo_ == &::google::protobuf::internal::kEmptyString) {
    countryinfo_ = new ::std::string;
  }
  countryinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogRequest_TerminalLog::mutable_countryinfo() {
  set_has_countryinfo();
  if (countryinfo_ == &::google::protobuf::internal::kEmptyString) {
    countryinfo_ = new ::std::string;
  }
  return countryinfo_;
}
inline ::std::string* LogRequest_TerminalLog::release_countryinfo() {
  clear_has_countryinfo();
  if (countryinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = countryinfo_;
    countryinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LogRequest_TerminalLog::set_allocated_countryinfo(::std::string* countryinfo) {
  if (countryinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete countryinfo_;
  }
  if (countryinfo) {
    set_has_countryinfo();
    countryinfo_ = countryinfo;
  } else {
    clear_has_countryinfo();
    countryinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string cityInfo = 8;
inline bool LogRequest_TerminalLog::has_cityinfo() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LogRequest_TerminalLog::set_has_cityinfo() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LogRequest_TerminalLog::clear_has_cityinfo() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LogRequest_TerminalLog::clear_cityinfo() {
  if (cityinfo_ != &::google::protobuf::internal::kEmptyString) {
    cityinfo_->clear();
  }
  clear_has_cityinfo();
}
inline const ::std::string& LogRequest_TerminalLog::cityinfo() const {
  return *cityinfo_;
}
inline void LogRequest_TerminalLog::set_cityinfo(const ::std::string& value) {
  set_has_cityinfo();
  if (cityinfo_ == &::google::protobuf::internal::kEmptyString) {
    cityinfo_ = new ::std::string;
  }
  cityinfo_->assign(value);
}
inline void LogRequest_TerminalLog::set_cityinfo(const char* value) {
  set_has_cityinfo();
  if (cityinfo_ == &::google::protobuf::internal::kEmptyString) {
    cityinfo_ = new ::std::string;
  }
  cityinfo_->assign(value);
}
inline void LogRequest_TerminalLog::set_cityinfo(const char* value, size_t size) {
  set_has_cityinfo();
  if (cityinfo_ == &::google::protobuf::internal::kEmptyString) {
    cityinfo_ = new ::std::string;
  }
  cityinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogRequest_TerminalLog::mutable_cityinfo() {
  set_has_cityinfo();
  if (cityinfo_ == &::google::protobuf::internal::kEmptyString) {
    cityinfo_ = new ::std::string;
  }
  return cityinfo_;
}
inline ::std::string* LogRequest_TerminalLog::release_cityinfo() {
  clear_has_cityinfo();
  if (cityinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cityinfo_;
    cityinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LogRequest_TerminalLog::set_allocated_cityinfo(::std::string* cityinfo) {
  if (cityinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete cityinfo_;
  }
  if (cityinfo) {
    set_has_cityinfo();
    cityinfo_ = cityinfo;
  } else {
    clear_has_cityinfo();
    cityinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LogRequest_GoodsLog

// optional int32 chID = 1;
inline bool LogRequest_GoodsLog::has_chid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogRequest_GoodsLog::set_has_chid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogRequest_GoodsLog::clear_has_chid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogRequest_GoodsLog::clear_chid() {
  chid_ = 0;
  clear_has_chid();
}
inline ::google::protobuf::int32 LogRequest_GoodsLog::chid() const {
  return chid_;
}
inline void LogRequest_GoodsLog::set_chid(::google::protobuf::int32 value) {
  set_has_chid();
  chid_ = value;
}

// optional .message.LogRequest.BuyType type = 2;
inline bool LogRequest_GoodsLog::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogRequest_GoodsLog::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogRequest_GoodsLog::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogRequest_GoodsLog::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::message::LogRequest_BuyType LogRequest_GoodsLog::type() const {
  return static_cast< ::message::LogRequest_BuyType >(type_);
}
inline void LogRequest_GoodsLog::set_type(::message::LogRequest_BuyType value) {
  assert(::message::LogRequest_BuyType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional int32 goodsID = 3;
inline bool LogRequest_GoodsLog::has_goodsid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogRequest_GoodsLog::set_has_goodsid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LogRequest_GoodsLog::clear_has_goodsid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LogRequest_GoodsLog::clear_goodsid() {
  goodsid_ = 0;
  clear_has_goodsid();
}
inline ::google::protobuf::int32 LogRequest_GoodsLog::goodsid() const {
  return goodsid_;
}
inline void LogRequest_GoodsLog::set_goodsid(::google::protobuf::int32 value) {
  set_has_goodsid();
  goodsid_ = value;
}

// optional int32 buySize = 4;
inline bool LogRequest_GoodsLog::has_buysize() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LogRequest_GoodsLog::set_has_buysize() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LogRequest_GoodsLog::clear_has_buysize() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LogRequest_GoodsLog::clear_buysize() {
  buysize_ = 0;
  clear_has_buysize();
}
inline ::google::protobuf::int32 LogRequest_GoodsLog::buysize() const {
  return buysize_;
}
inline void LogRequest_GoodsLog::set_buysize(::google::protobuf::int32 value) {
  set_has_buysize();
  buysize_ = value;
}

// optional .message.LogRequest.BuyState state = 5;
inline bool LogRequest_GoodsLog::has_state() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LogRequest_GoodsLog::set_has_state() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LogRequest_GoodsLog::clear_has_state() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LogRequest_GoodsLog::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::message::LogRequest_BuyState LogRequest_GoodsLog::state() const {
  return static_cast< ::message::LogRequest_BuyState >(state_);
}
inline void LogRequest_GoodsLog::set_state(::message::LogRequest_BuyState value) {
  assert(::message::LogRequest_BuyState_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional uint64 buyTime = 6;
inline bool LogRequest_GoodsLog::has_buytime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LogRequest_GoodsLog::set_has_buytime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LogRequest_GoodsLog::clear_has_buytime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LogRequest_GoodsLog::clear_buytime() {
  buytime_ = GOOGLE_ULONGLONG(0);
  clear_has_buytime();
}
inline ::google::protobuf::uint64 LogRequest_GoodsLog::buytime() const {
  return buytime_;
}
inline void LogRequest_GoodsLog::set_buytime(::google::protobuf::uint64 value) {
  set_has_buytime();
  buytime_ = value;
}

// optional uint64 sTime = 7;
inline bool LogRequest_GoodsLog::has_stime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LogRequest_GoodsLog::set_has_stime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LogRequest_GoodsLog::clear_has_stime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LogRequest_GoodsLog::clear_stime() {
  stime_ = GOOGLE_ULONGLONG(0);
  clear_has_stime();
}
inline ::google::protobuf::uint64 LogRequest_GoodsLog::stime() const {
  return stime_;
}
inline void LogRequest_GoodsLog::set_stime(::google::protobuf::uint64 value) {
  set_has_stime();
  stime_ = value;
}

// -------------------------------------------------------------------

// LogRequest

// repeated .message.LogRequest.UserLog userLogs = 1;
inline int LogRequest::userlogs_size() const {
  return userlogs_.size();
}
inline void LogRequest::clear_userlogs() {
  userlogs_.Clear();
}
inline const ::message::LogRequest_UserLog& LogRequest::userlogs(int index) const {
  return userlogs_.Get(index);
}
inline ::message::LogRequest_UserLog* LogRequest::mutable_userlogs(int index) {
  return userlogs_.Mutable(index);
}
inline ::message::LogRequest_UserLog* LogRequest::add_userlogs() {
  return userlogs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::LogRequest_UserLog >&
LogRequest::userlogs() const {
  return userlogs_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::LogRequest_UserLog >*
LogRequest::mutable_userlogs() {
  return &userlogs_;
}

// optional .message.LogRequest.TerminalLog terminalLogs = 2;
inline bool LogRequest::has_terminallogs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogRequest::set_has_terminallogs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogRequest::clear_has_terminallogs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogRequest::clear_terminallogs() {
  if (terminallogs_ != NULL) terminallogs_->::message::LogRequest_TerminalLog::Clear();
  clear_has_terminallogs();
}
inline const ::message::LogRequest_TerminalLog& LogRequest::terminallogs() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return terminallogs_ != NULL ? *terminallogs_ : *default_instance().terminallogs_;
#else
  return terminallogs_ != NULL ? *terminallogs_ : *default_instance_->terminallogs_;
#endif
}
inline ::message::LogRequest_TerminalLog* LogRequest::mutable_terminallogs() {
  set_has_terminallogs();
  if (terminallogs_ == NULL) terminallogs_ = new ::message::LogRequest_TerminalLog;
  return terminallogs_;
}
inline ::message::LogRequest_TerminalLog* LogRequest::release_terminallogs() {
  clear_has_terminallogs();
  ::message::LogRequest_TerminalLog* temp = terminallogs_;
  terminallogs_ = NULL;
  return temp;
}
inline void LogRequest::set_allocated_terminallogs(::message::LogRequest_TerminalLog* terminallogs) {
  delete terminallogs_;
  terminallogs_ = terminallogs;
  if (terminallogs) {
    set_has_terminallogs();
  } else {
    clear_has_terminallogs();
  }
}

// repeated .message.LogRequest.GoodsLog goodsLog = 3;
inline int LogRequest::goodslog_size() const {
  return goodslog_.size();
}
inline void LogRequest::clear_goodslog() {
  goodslog_.Clear();
}
inline const ::message::LogRequest_GoodsLog& LogRequest::goodslog(int index) const {
  return goodslog_.Get(index);
}
inline ::message::LogRequest_GoodsLog* LogRequest::mutable_goodslog(int index) {
  return goodslog_.Mutable(index);
}
inline ::message::LogRequest_GoodsLog* LogRequest::add_goodslog() {
  return goodslog_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::LogRequest_GoodsLog >&
LogRequest::goodslog() const {
  return goodslog_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::LogRequest_GoodsLog >*
LogRequest::mutable_goodslog() {
  return &goodslog_;
}

// -------------------------------------------------------------------

// LogResponse

// required .message.LogResponse.ResultStatus status = 1;
inline bool LogResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::message::LogResponse_ResultStatus LogResponse::status() const {
  return static_cast< ::message::LogResponse_ResultStatus >(status_);
}
inline void LogResponse::set_status(::message::LogResponse_ResultStatus value) {
  assert(::message::LogResponse_ResultStatus_IsValid(value));
  set_has_status();
  status_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace message

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_GameLog_2eproto__INCLUDED
