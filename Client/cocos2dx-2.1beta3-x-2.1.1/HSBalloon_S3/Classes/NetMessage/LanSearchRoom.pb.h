// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: LanSearchRoom.proto

#ifndef PROTOBUF_LanSearchRoom_2eproto__INCLUDED
#define PROTOBUF_LanSearchRoom_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace message {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_LanSearchRoom_2eproto();
void protobuf_AssignDesc_LanSearchRoom_2eproto();
void protobuf_ShutdownFile_LanSearchRoom_2eproto();

class LanSearchRoomRequest;
class LanSearchRoomResponse;
class LanSearchRoomResponse_room;

// ===================================================================

class LanSearchRoomRequest : public ::google::protobuf::MessageLite {
 public:
  LanSearchRoomRequest();
  virtual ~LanSearchRoomRequest();

  LanSearchRoomRequest(const LanSearchRoomRequest& from);

  inline LanSearchRoomRequest& operator=(const LanSearchRoomRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const LanSearchRoomRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LanSearchRoomRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LanSearchRoomRequest* other);

  // implements Message ----------------------------------------------

  LanSearchRoomRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LanSearchRoomRequest& from);
  void MergeFrom(const LanSearchRoomRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 jsonID = 1;
  inline bool has_jsonid() const;
  inline void clear_jsonid();
  static const int kJsonIDFieldNumber = 1;
  inline ::google::protobuf::int32 jsonid() const;
  inline void set_jsonid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:message.LanSearchRoomRequest)
 private:
  inline void set_has_jsonid();
  inline void clear_has_jsonid();

  ::google::protobuf::int32 jsonid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_LanSearchRoom_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_LanSearchRoom_2eproto();
  #endif
  friend void protobuf_AssignDesc_LanSearchRoom_2eproto();
  friend void protobuf_ShutdownFile_LanSearchRoom_2eproto();

  void InitAsDefaultInstance();
  static LanSearchRoomRequest* default_instance_;
};
// -------------------------------------------------------------------

class LanSearchRoomResponse_room : public ::google::protobuf::MessageLite {
 public:
  LanSearchRoomResponse_room();
  virtual ~LanSearchRoomResponse_room();

  LanSearchRoomResponse_room(const LanSearchRoomResponse_room& from);

  inline LanSearchRoomResponse_room& operator=(const LanSearchRoomResponse_room& from) {
    CopyFrom(from);
    return *this;
  }

  static const LanSearchRoomResponse_room& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LanSearchRoomResponse_room* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LanSearchRoomResponse_room* other);

  // implements Message ----------------------------------------------

  LanSearchRoomResponse_room* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LanSearchRoomResponse_room& from);
  void MergeFrom(const LanSearchRoomResponse_room& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string JNI_EGG_ROOM_NAME = 1;
  inline bool has_jni_egg_room_name() const;
  inline void clear_jni_egg_room_name();
  static const int kJNIEGGROOMNAMEFieldNumber = 1;
  inline const ::std::string& jni_egg_room_name() const;
  inline void set_jni_egg_room_name(const ::std::string& value);
  inline void set_jni_egg_room_name(const char* value);
  inline void set_jni_egg_room_name(const char* value, size_t size);
  inline ::std::string* mutable_jni_egg_room_name();
  inline ::std::string* release_jni_egg_room_name();
  inline void set_allocated_jni_egg_room_name(::std::string* jni_egg_room_name);

  // required int32 JNI_EGG_ROOM_MAXNUM = 2;
  inline bool has_jni_egg_room_maxnum() const;
  inline void clear_jni_egg_room_maxnum();
  static const int kJNIEGGROOMMAXNUMFieldNumber = 2;
  inline ::google::protobuf::int32 jni_egg_room_maxnum() const;
  inline void set_jni_egg_room_maxnum(::google::protobuf::int32 value);

  // required int32 JNI_EGG_ROOM_CURNUM = 3;
  inline bool has_jni_egg_room_curnum() const;
  inline void clear_jni_egg_room_curnum();
  static const int kJNIEGGROOMCURNUMFieldNumber = 3;
  inline ::google::protobuf::int32 jni_egg_room_curnum() const;
  inline void set_jni_egg_room_curnum(::google::protobuf::int32 value);

  // required string JNI_EGG_SSID = 4;
  inline bool has_jni_egg_ssid() const;
  inline void clear_jni_egg_ssid();
  static const int kJNIEGGSSIDFieldNumber = 4;
  inline const ::std::string& jni_egg_ssid() const;
  inline void set_jni_egg_ssid(const ::std::string& value);
  inline void set_jni_egg_ssid(const char* value);
  inline void set_jni_egg_ssid(const char* value, size_t size);
  inline ::std::string* mutable_jni_egg_ssid();
  inline ::std::string* release_jni_egg_ssid();
  inline void set_allocated_jni_egg_ssid(::std::string* jni_egg_ssid);

  // @@protoc_insertion_point(class_scope:message.LanSearchRoomResponse.room)
 private:
  inline void set_has_jni_egg_room_name();
  inline void clear_has_jni_egg_room_name();
  inline void set_has_jni_egg_room_maxnum();
  inline void clear_has_jni_egg_room_maxnum();
  inline void set_has_jni_egg_room_curnum();
  inline void clear_has_jni_egg_room_curnum();
  inline void set_has_jni_egg_ssid();
  inline void clear_has_jni_egg_ssid();

  ::std::string* jni_egg_room_name_;
  ::google::protobuf::int32 jni_egg_room_maxnum_;
  ::google::protobuf::int32 jni_egg_room_curnum_;
  ::std::string* jni_egg_ssid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_LanSearchRoom_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_LanSearchRoom_2eproto();
  #endif
  friend void protobuf_AssignDesc_LanSearchRoom_2eproto();
  friend void protobuf_ShutdownFile_LanSearchRoom_2eproto();

  void InitAsDefaultInstance();
  static LanSearchRoomResponse_room* default_instance_;
};
// -------------------------------------------------------------------

class LanSearchRoomResponse : public ::google::protobuf::MessageLite {
 public:
  LanSearchRoomResponse();
  virtual ~LanSearchRoomResponse();

  LanSearchRoomResponse(const LanSearchRoomResponse& from);

  inline LanSearchRoomResponse& operator=(const LanSearchRoomResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const LanSearchRoomResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LanSearchRoomResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LanSearchRoomResponse* other);

  // implements Message ----------------------------------------------

  LanSearchRoomResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LanSearchRoomResponse& from);
  void MergeFrom(const LanSearchRoomResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef LanSearchRoomResponse_room room;

  // accessors -------------------------------------------------------

  // required int32 jsonID = 1;
  inline bool has_jsonid() const;
  inline void clear_jsonid();
  static const int kJsonIDFieldNumber = 1;
  inline ::google::protobuf::int32 jsonid() const;
  inline void set_jsonid(::google::protobuf::int32 value);

  // repeated .message.LanSearchRoomResponse.room roomList = 2;
  inline int roomlist_size() const;
  inline void clear_roomlist();
  static const int kRoomListFieldNumber = 2;
  inline const ::message::LanSearchRoomResponse_room& roomlist(int index) const;
  inline ::message::LanSearchRoomResponse_room* mutable_roomlist(int index);
  inline ::message::LanSearchRoomResponse_room* add_roomlist();
  inline const ::google::protobuf::RepeatedPtrField< ::message::LanSearchRoomResponse_room >&
      roomlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::LanSearchRoomResponse_room >*
      mutable_roomlist();

  // @@protoc_insertion_point(class_scope:message.LanSearchRoomResponse)
 private:
  inline void set_has_jsonid();
  inline void clear_has_jsonid();

  ::google::protobuf::RepeatedPtrField< ::message::LanSearchRoomResponse_room > roomlist_;
  ::google::protobuf::int32 jsonid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_LanSearchRoom_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_LanSearchRoom_2eproto();
  #endif
  friend void protobuf_AssignDesc_LanSearchRoom_2eproto();
  friend void protobuf_ShutdownFile_LanSearchRoom_2eproto();

  void InitAsDefaultInstance();
  static LanSearchRoomResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// LanSearchRoomRequest

// required int32 jsonID = 1;
inline bool LanSearchRoomRequest::has_jsonid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LanSearchRoomRequest::set_has_jsonid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LanSearchRoomRequest::clear_has_jsonid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LanSearchRoomRequest::clear_jsonid() {
  jsonid_ = 0;
  clear_has_jsonid();
}
inline ::google::protobuf::int32 LanSearchRoomRequest::jsonid() const {
  return jsonid_;
}
inline void LanSearchRoomRequest::set_jsonid(::google::protobuf::int32 value) {
  set_has_jsonid();
  jsonid_ = value;
}

// -------------------------------------------------------------------

// LanSearchRoomResponse_room

// required string JNI_EGG_ROOM_NAME = 1;
inline bool LanSearchRoomResponse_room::has_jni_egg_room_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LanSearchRoomResponse_room::set_has_jni_egg_room_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LanSearchRoomResponse_room::clear_has_jni_egg_room_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LanSearchRoomResponse_room::clear_jni_egg_room_name() {
  if (jni_egg_room_name_ != &::google::protobuf::internal::kEmptyString) {
    jni_egg_room_name_->clear();
  }
  clear_has_jni_egg_room_name();
}
inline const ::std::string& LanSearchRoomResponse_room::jni_egg_room_name() const {
  return *jni_egg_room_name_;
}
inline void LanSearchRoomResponse_room::set_jni_egg_room_name(const ::std::string& value) {
  set_has_jni_egg_room_name();
  if (jni_egg_room_name_ == &::google::protobuf::internal::kEmptyString) {
    jni_egg_room_name_ = new ::std::string;
  }
  jni_egg_room_name_->assign(value);
}
inline void LanSearchRoomResponse_room::set_jni_egg_room_name(const char* value) {
  set_has_jni_egg_room_name();
  if (jni_egg_room_name_ == &::google::protobuf::internal::kEmptyString) {
    jni_egg_room_name_ = new ::std::string;
  }
  jni_egg_room_name_->assign(value);
}
inline void LanSearchRoomResponse_room::set_jni_egg_room_name(const char* value, size_t size) {
  set_has_jni_egg_room_name();
  if (jni_egg_room_name_ == &::google::protobuf::internal::kEmptyString) {
    jni_egg_room_name_ = new ::std::string;
  }
  jni_egg_room_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LanSearchRoomResponse_room::mutable_jni_egg_room_name() {
  set_has_jni_egg_room_name();
  if (jni_egg_room_name_ == &::google::protobuf::internal::kEmptyString) {
    jni_egg_room_name_ = new ::std::string;
  }
  return jni_egg_room_name_;
}
inline ::std::string* LanSearchRoomResponse_room::release_jni_egg_room_name() {
  clear_has_jni_egg_room_name();
  if (jni_egg_room_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = jni_egg_room_name_;
    jni_egg_room_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LanSearchRoomResponse_room::set_allocated_jni_egg_room_name(::std::string* jni_egg_room_name) {
  if (jni_egg_room_name_ != &::google::protobuf::internal::kEmptyString) {
    delete jni_egg_room_name_;
  }
  if (jni_egg_room_name) {
    set_has_jni_egg_room_name();
    jni_egg_room_name_ = jni_egg_room_name;
  } else {
    clear_has_jni_egg_room_name();
    jni_egg_room_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 JNI_EGG_ROOM_MAXNUM = 2;
inline bool LanSearchRoomResponse_room::has_jni_egg_room_maxnum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LanSearchRoomResponse_room::set_has_jni_egg_room_maxnum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LanSearchRoomResponse_room::clear_has_jni_egg_room_maxnum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LanSearchRoomResponse_room::clear_jni_egg_room_maxnum() {
  jni_egg_room_maxnum_ = 0;
  clear_has_jni_egg_room_maxnum();
}
inline ::google::protobuf::int32 LanSearchRoomResponse_room::jni_egg_room_maxnum() const {
  return jni_egg_room_maxnum_;
}
inline void LanSearchRoomResponse_room::set_jni_egg_room_maxnum(::google::protobuf::int32 value) {
  set_has_jni_egg_room_maxnum();
  jni_egg_room_maxnum_ = value;
}

// required int32 JNI_EGG_ROOM_CURNUM = 3;
inline bool LanSearchRoomResponse_room::has_jni_egg_room_curnum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LanSearchRoomResponse_room::set_has_jni_egg_room_curnum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LanSearchRoomResponse_room::clear_has_jni_egg_room_curnum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LanSearchRoomResponse_room::clear_jni_egg_room_curnum() {
  jni_egg_room_curnum_ = 0;
  clear_has_jni_egg_room_curnum();
}
inline ::google::protobuf::int32 LanSearchRoomResponse_room::jni_egg_room_curnum() const {
  return jni_egg_room_curnum_;
}
inline void LanSearchRoomResponse_room::set_jni_egg_room_curnum(::google::protobuf::int32 value) {
  set_has_jni_egg_room_curnum();
  jni_egg_room_curnum_ = value;
}

// required string JNI_EGG_SSID = 4;
inline bool LanSearchRoomResponse_room::has_jni_egg_ssid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LanSearchRoomResponse_room::set_has_jni_egg_ssid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LanSearchRoomResponse_room::clear_has_jni_egg_ssid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LanSearchRoomResponse_room::clear_jni_egg_ssid() {
  if (jni_egg_ssid_ != &::google::protobuf::internal::kEmptyString) {
    jni_egg_ssid_->clear();
  }
  clear_has_jni_egg_ssid();
}
inline const ::std::string& LanSearchRoomResponse_room::jni_egg_ssid() const {
  return *jni_egg_ssid_;
}
inline void LanSearchRoomResponse_room::set_jni_egg_ssid(const ::std::string& value) {
  set_has_jni_egg_ssid();
  if (jni_egg_ssid_ == &::google::protobuf::internal::kEmptyString) {
    jni_egg_ssid_ = new ::std::string;
  }
  jni_egg_ssid_->assign(value);
}
inline void LanSearchRoomResponse_room::set_jni_egg_ssid(const char* value) {
  set_has_jni_egg_ssid();
  if (jni_egg_ssid_ == &::google::protobuf::internal::kEmptyString) {
    jni_egg_ssid_ = new ::std::string;
  }
  jni_egg_ssid_->assign(value);
}
inline void LanSearchRoomResponse_room::set_jni_egg_ssid(const char* value, size_t size) {
  set_has_jni_egg_ssid();
  if (jni_egg_ssid_ == &::google::protobuf::internal::kEmptyString) {
    jni_egg_ssid_ = new ::std::string;
  }
  jni_egg_ssid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LanSearchRoomResponse_room::mutable_jni_egg_ssid() {
  set_has_jni_egg_ssid();
  if (jni_egg_ssid_ == &::google::protobuf::internal::kEmptyString) {
    jni_egg_ssid_ = new ::std::string;
  }
  return jni_egg_ssid_;
}
inline ::std::string* LanSearchRoomResponse_room::release_jni_egg_ssid() {
  clear_has_jni_egg_ssid();
  if (jni_egg_ssid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = jni_egg_ssid_;
    jni_egg_ssid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LanSearchRoomResponse_room::set_allocated_jni_egg_ssid(::std::string* jni_egg_ssid) {
  if (jni_egg_ssid_ != &::google::protobuf::internal::kEmptyString) {
    delete jni_egg_ssid_;
  }
  if (jni_egg_ssid) {
    set_has_jni_egg_ssid();
    jni_egg_ssid_ = jni_egg_ssid;
  } else {
    clear_has_jni_egg_ssid();
    jni_egg_ssid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LanSearchRoomResponse

// required int32 jsonID = 1;
inline bool LanSearchRoomResponse::has_jsonid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LanSearchRoomResponse::set_has_jsonid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LanSearchRoomResponse::clear_has_jsonid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LanSearchRoomResponse::clear_jsonid() {
  jsonid_ = 0;
  clear_has_jsonid();
}
inline ::google::protobuf::int32 LanSearchRoomResponse::jsonid() const {
  return jsonid_;
}
inline void LanSearchRoomResponse::set_jsonid(::google::protobuf::int32 value) {
  set_has_jsonid();
  jsonid_ = value;
}

// repeated .message.LanSearchRoomResponse.room roomList = 2;
inline int LanSearchRoomResponse::roomlist_size() const {
  return roomlist_.size();
}
inline void LanSearchRoomResponse::clear_roomlist() {
  roomlist_.Clear();
}
inline const ::message::LanSearchRoomResponse_room& LanSearchRoomResponse::roomlist(int index) const {
  return roomlist_.Get(index);
}
inline ::message::LanSearchRoomResponse_room* LanSearchRoomResponse::mutable_roomlist(int index) {
  return roomlist_.Mutable(index);
}
inline ::message::LanSearchRoomResponse_room* LanSearchRoomResponse::add_roomlist() {
  return roomlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::LanSearchRoomResponse_room >&
LanSearchRoomResponse::roomlist() const {
  return roomlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::LanSearchRoomResponse_room >*
LanSearchRoomResponse::mutable_roomlist() {
  return &roomlist_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace message

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_LanSearchRoom_2eproto__INCLUDED
