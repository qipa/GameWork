// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: HSGameGuide.proto

#ifndef PROTOBUF_HSGameGuide_2eproto__INCLUDED
#define PROTOBUF_HSGameGuide_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace message {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_HSGameGuide_2eproto();
void protobuf_AssignDesc_HSGameGuide_2eproto();
void protobuf_ShutdownFile_HSGameGuide_2eproto();

class GameGuide;
class GameGuide_Guide;
class GameGuide_Guide_Point;
class GameGuide_BattleLayout;
class GameGuide_BattleLayout_BalloonInfo;
class GameGuide_BattleLayout_Move;

enum GameGuide_Guide_ModeType {
  GameGuide_Guide_ModeType_ModeType_Rect = 0,
  GameGuide_Guide_ModeType_ModeType_Round = 1,
  GameGuide_Guide_ModeType_ModeType_NULL = 2
};
bool GameGuide_Guide_ModeType_IsValid(int value);
const GameGuide_Guide_ModeType GameGuide_Guide_ModeType_ModeType_MIN = GameGuide_Guide_ModeType_ModeType_Rect;
const GameGuide_Guide_ModeType GameGuide_Guide_ModeType_ModeType_MAX = GameGuide_Guide_ModeType_ModeType_NULL;
const int GameGuide_Guide_ModeType_ModeType_ARRAYSIZE = GameGuide_Guide_ModeType_ModeType_MAX + 1;

enum GameGuide_Guide_MirrorType {
  GameGuide_Guide_MirrorType_MirrorType_X = 0,
  GameGuide_Guide_MirrorType_MirrorType_Y = 1
};
bool GameGuide_Guide_MirrorType_IsValid(int value);
const GameGuide_Guide_MirrorType GameGuide_Guide_MirrorType_MirrorType_MIN = GameGuide_Guide_MirrorType_MirrorType_X;
const GameGuide_Guide_MirrorType GameGuide_Guide_MirrorType_MirrorType_MAX = GameGuide_Guide_MirrorType_MirrorType_Y;
const int GameGuide_Guide_MirrorType_MirrorType_ARRAYSIZE = GameGuide_Guide_MirrorType_MirrorType_MAX + 1;

// ===================================================================

class GameGuide_Guide_Point : public ::google::protobuf::MessageLite {
 public:
  GameGuide_Guide_Point();
  virtual ~GameGuide_Guide_Point();

  GameGuide_Guide_Point(const GameGuide_Guide_Point& from);

  inline GameGuide_Guide_Point& operator=(const GameGuide_Guide_Point& from) {
    CopyFrom(from);
    return *this;
  }

  static const GameGuide_Guide_Point& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GameGuide_Guide_Point* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GameGuide_Guide_Point* other);

  // implements Message ----------------------------------------------

  GameGuide_Guide_Point* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameGuide_Guide_Point& from);
  void MergeFrom(const GameGuide_Guide_Point& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // @@protoc_insertion_point(class_scope:message.GameGuide.Guide.Point)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  float x_;
  float y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_HSGameGuide_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_HSGameGuide_2eproto();
  #endif
  friend void protobuf_AssignDesc_HSGameGuide_2eproto();
  friend void protobuf_ShutdownFile_HSGameGuide_2eproto();

  void InitAsDefaultInstance();
  static GameGuide_Guide_Point* default_instance_;
};
// -------------------------------------------------------------------

class GameGuide_Guide : public ::google::protobuf::MessageLite {
 public:
  GameGuide_Guide();
  virtual ~GameGuide_Guide();

  GameGuide_Guide(const GameGuide_Guide& from);

  inline GameGuide_Guide& operator=(const GameGuide_Guide& from) {
    CopyFrom(from);
    return *this;
  }

  static const GameGuide_Guide& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GameGuide_Guide* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GameGuide_Guide* other);

  // implements Message ----------------------------------------------

  GameGuide_Guide* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameGuide_Guide& from);
  void MergeFrom(const GameGuide_Guide& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef GameGuide_Guide_Point Point;

  typedef GameGuide_Guide_ModeType ModeType;
  static const ModeType ModeType_Rect = GameGuide_Guide_ModeType_ModeType_Rect;
  static const ModeType ModeType_Round = GameGuide_Guide_ModeType_ModeType_Round;
  static const ModeType ModeType_NULL = GameGuide_Guide_ModeType_ModeType_NULL;
  static inline bool ModeType_IsValid(int value) {
    return GameGuide_Guide_ModeType_IsValid(value);
  }
  static const ModeType ModeType_MIN =
    GameGuide_Guide_ModeType_ModeType_MIN;
  static const ModeType ModeType_MAX =
    GameGuide_Guide_ModeType_ModeType_MAX;
  static const int ModeType_ARRAYSIZE =
    GameGuide_Guide_ModeType_ModeType_ARRAYSIZE;

  typedef GameGuide_Guide_MirrorType MirrorType;
  static const MirrorType MirrorType_X = GameGuide_Guide_MirrorType_MirrorType_X;
  static const MirrorType MirrorType_Y = GameGuide_Guide_MirrorType_MirrorType_Y;
  static inline bool MirrorType_IsValid(int value) {
    return GameGuide_Guide_MirrorType_IsValid(value);
  }
  static const MirrorType MirrorType_MIN =
    GameGuide_Guide_MirrorType_MirrorType_MIN;
  static const MirrorType MirrorType_MAX =
    GameGuide_Guide_MirrorType_MirrorType_MAX;
  static const int MirrorType_ARRAYSIZE =
    GameGuide_Guide_MirrorType_MirrorType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required bool isInterceptTouch = 2;
  inline bool has_isintercepttouch() const;
  inline void clear_isintercepttouch();
  static const int kIsInterceptTouchFieldNumber = 2;
  inline bool isintercepttouch() const;
  inline void set_isintercepttouch(bool value);

  // required bool isShowMask = 3;
  inline bool has_isshowmask() const;
  inline void clear_isshowmask();
  static const int kIsShowMaskFieldNumber = 3;
  inline bool isshowmask() const;
  inline void set_isshowmask(bool value);

  // required bool isShowHole = 4;
  inline bool has_isshowhole() const;
  inline void clear_isshowhole();
  static const int kIsShowHoleFieldNumber = 4;
  inline bool isshowhole() const;
  inline void set_isshowhole(bool value);

  // required bool isPause = 5;
  inline bool has_ispause() const;
  inline void clear_ispause();
  static const int kIsPauseFieldNumber = 5;
  inline bool ispause() const;
  inline void set_ispause(bool value);

  // optional .message.GameGuide.Guide.ModeType modeType = 6;
  inline bool has_modetype() const;
  inline void clear_modetype();
  static const int kModeTypeFieldNumber = 6;
  inline ::message::GameGuide_Guide_ModeType modetype() const;
  inline void set_modetype(::message::GameGuide_Guide_ModeType value);

  // optional .message.GameGuide.Guide.Point modePos = 7;
  inline bool has_modepos() const;
  inline void clear_modepos();
  static const int kModePosFieldNumber = 7;
  inline const ::message::GameGuide_Guide_Point& modepos() const;
  inline ::message::GameGuide_Guide_Point* mutable_modepos();
  inline ::message::GameGuide_Guide_Point* release_modepos();
  inline void set_allocated_modepos(::message::GameGuide_Guide_Point* modepos);

  // optional float w = 8;
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 8;
  inline float w() const;
  inline void set_w(float value);

  // optional float h = 9;
  inline bool has_h() const;
  inline void clear_h();
  static const int kHFieldNumber = 9;
  inline float h() const;
  inline void set_h(float value);

  // optional .message.GameGuide.Guide.Point indicationSignPos = 10;
  inline bool has_indicationsignpos() const;
  inline void clear_indicationsignpos();
  static const int kIndicationSignPosFieldNumber = 10;
  inline const ::message::GameGuide_Guide_Point& indicationsignpos() const;
  inline ::message::GameGuide_Guide_Point* mutable_indicationsignpos();
  inline ::message::GameGuide_Guide_Point* release_indicationsignpos();
  inline void set_allocated_indicationsignpos(::message::GameGuide_Guide_Point* indicationsignpos);

  // optional .message.GameGuide.Guide.MirrorType mirror = 11;
  inline bool has_mirror() const;
  inline void clear_mirror();
  static const int kMirrorFieldNumber = 11;
  inline ::message::GameGuide_Guide_MirrorType mirror() const;
  inline void set_mirror(::message::GameGuide_Guide_MirrorType value);

  // optional float rotate = 12 [default = 0];
  inline bool has_rotate() const;
  inline void clear_rotate();
  static const int kRotateFieldNumber = 12;
  inline float rotate() const;
  inline void set_rotate(float value);

  // optional .message.GameGuide.Guide.Point describeFramePos = 13;
  inline bool has_describeframepos() const;
  inline void clear_describeframepos();
  static const int kDescribeFramePosFieldNumber = 13;
  inline const ::message::GameGuide_Guide_Point& describeframepos() const;
  inline ::message::GameGuide_Guide_Point* mutable_describeframepos();
  inline ::message::GameGuide_Guide_Point* release_describeframepos();
  inline void set_allocated_describeframepos(::message::GameGuide_Guide_Point* describeframepos);

  // optional string describe = 14 [default = ""];
  inline bool has_describe() const;
  inline void clear_describe();
  static const int kDescribeFieldNumber = 14;
  inline const ::std::string& describe() const;
  inline void set_describe(const ::std::string& value);
  inline void set_describe(const char* value);
  inline void set_describe(const char* value, size_t size);
  inline ::std::string* mutable_describe();
  inline ::std::string* release_describe();
  inline void set_allocated_describe(::std::string* describe);

  // @@protoc_insertion_point(class_scope:message.GameGuide.Guide)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_isintercepttouch();
  inline void clear_has_isintercepttouch();
  inline void set_has_isshowmask();
  inline void clear_has_isshowmask();
  inline void set_has_isshowhole();
  inline void clear_has_isshowhole();
  inline void set_has_ispause();
  inline void clear_has_ispause();
  inline void set_has_modetype();
  inline void clear_has_modetype();
  inline void set_has_modepos();
  inline void clear_has_modepos();
  inline void set_has_w();
  inline void clear_has_w();
  inline void set_has_h();
  inline void clear_has_h();
  inline void set_has_indicationsignpos();
  inline void clear_has_indicationsignpos();
  inline void set_has_mirror();
  inline void clear_has_mirror();
  inline void set_has_rotate();
  inline void clear_has_rotate();
  inline void set_has_describeframepos();
  inline void clear_has_describeframepos();
  inline void set_has_describe();
  inline void clear_has_describe();

  ::google::protobuf::int32 id_;
  bool isintercepttouch_;
  bool isshowmask_;
  bool isshowhole_;
  bool ispause_;
  ::message::GameGuide_Guide_Point* modepos_;
  int modetype_;
  float w_;
  ::message::GameGuide_Guide_Point* indicationsignpos_;
  float h_;
  int mirror_;
  ::message::GameGuide_Guide_Point* describeframepos_;
  ::std::string* describe_;
  float rotate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_HSGameGuide_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_HSGameGuide_2eproto();
  #endif
  friend void protobuf_AssignDesc_HSGameGuide_2eproto();
  friend void protobuf_ShutdownFile_HSGameGuide_2eproto();

  void InitAsDefaultInstance();
  static GameGuide_Guide* default_instance_;
};
// -------------------------------------------------------------------

class GameGuide_BattleLayout_BalloonInfo : public ::google::protobuf::MessageLite {
 public:
  GameGuide_BattleLayout_BalloonInfo();
  virtual ~GameGuide_BattleLayout_BalloonInfo();

  GameGuide_BattleLayout_BalloonInfo(const GameGuide_BattleLayout_BalloonInfo& from);

  inline GameGuide_BattleLayout_BalloonInfo& operator=(const GameGuide_BattleLayout_BalloonInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const GameGuide_BattleLayout_BalloonInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GameGuide_BattleLayout_BalloonInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GameGuide_BattleLayout_BalloonInfo* other);

  // implements Message ----------------------------------------------

  GameGuide_BattleLayout_BalloonInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameGuide_BattleLayout_BalloonInfo& from);
  void MergeFrom(const GameGuide_BattleLayout_BalloonInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required float x = 2;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline float x() const;
  inline void set_x(float value);

  // required float y = 3;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline float y() const;
  inline void set_y(float value);

  // required int32 color = 4;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 4;
  inline ::google::protobuf::int32 color() const;
  inline void set_color(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:message.GameGuide.BattleLayout.BalloonInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_color();
  inline void clear_has_color();

  ::google::protobuf::int32 id_;
  float x_;
  float y_;
  ::google::protobuf::int32 color_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_HSGameGuide_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_HSGameGuide_2eproto();
  #endif
  friend void protobuf_AssignDesc_HSGameGuide_2eproto();
  friend void protobuf_ShutdownFile_HSGameGuide_2eproto();

  void InitAsDefaultInstance();
  static GameGuide_BattleLayout_BalloonInfo* default_instance_;
};
// -------------------------------------------------------------------

class GameGuide_BattleLayout_Move : public ::google::protobuf::MessageLite {
 public:
  GameGuide_BattleLayout_Move();
  virtual ~GameGuide_BattleLayout_Move();

  GameGuide_BattleLayout_Move(const GameGuide_BattleLayout_Move& from);

  inline GameGuide_BattleLayout_Move& operator=(const GameGuide_BattleLayout_Move& from) {
    CopyFrom(from);
    return *this;
  }

  static const GameGuide_BattleLayout_Move& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GameGuide_BattleLayout_Move* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GameGuide_BattleLayout_Move* other);

  // implements Message ----------------------------------------------

  GameGuide_BattleLayout_Move* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameGuide_BattleLayout_Move& from);
  void MergeFrom(const GameGuide_BattleLayout_Move& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 beginID = 1;
  inline bool has_beginid() const;
  inline void clear_beginid();
  static const int kBeginIDFieldNumber = 1;
  inline ::google::protobuf::int32 beginid() const;
  inline void set_beginid(::google::protobuf::int32 value);

  // required int32 endID = 2;
  inline bool has_endid() const;
  inline void clear_endid();
  static const int kEndIDFieldNumber = 2;
  inline ::google::protobuf::int32 endid() const;
  inline void set_endid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:message.GameGuide.BattleLayout.Move)
 private:
  inline void set_has_beginid();
  inline void clear_has_beginid();
  inline void set_has_endid();
  inline void clear_has_endid();

  ::google::protobuf::int32 beginid_;
  ::google::protobuf::int32 endid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_HSGameGuide_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_HSGameGuide_2eproto();
  #endif
  friend void protobuf_AssignDesc_HSGameGuide_2eproto();
  friend void protobuf_ShutdownFile_HSGameGuide_2eproto();

  void InitAsDefaultInstance();
  static GameGuide_BattleLayout_Move* default_instance_;
};
// -------------------------------------------------------------------

class GameGuide_BattleLayout : public ::google::protobuf::MessageLite {
 public:
  GameGuide_BattleLayout();
  virtual ~GameGuide_BattleLayout();

  GameGuide_BattleLayout(const GameGuide_BattleLayout& from);

  inline GameGuide_BattleLayout& operator=(const GameGuide_BattleLayout& from) {
    CopyFrom(from);
    return *this;
  }

  static const GameGuide_BattleLayout& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GameGuide_BattleLayout* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GameGuide_BattleLayout* other);

  // implements Message ----------------------------------------------

  GameGuide_BattleLayout* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameGuide_BattleLayout& from);
  void MergeFrom(const GameGuide_BattleLayout& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef GameGuide_BattleLayout_BalloonInfo BalloonInfo;
  typedef GameGuide_BattleLayout_Move Move;

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // repeated .message.GameGuide.BattleLayout.BalloonInfo balloonInfoList = 2;
  inline int ballooninfolist_size() const;
  inline void clear_ballooninfolist();
  static const int kBalloonInfoListFieldNumber = 2;
  inline const ::message::GameGuide_BattleLayout_BalloonInfo& ballooninfolist(int index) const;
  inline ::message::GameGuide_BattleLayout_BalloonInfo* mutable_ballooninfolist(int index);
  inline ::message::GameGuide_BattleLayout_BalloonInfo* add_ballooninfolist();
  inline const ::google::protobuf::RepeatedPtrField< ::message::GameGuide_BattleLayout_BalloonInfo >&
      ballooninfolist() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::GameGuide_BattleLayout_BalloonInfo >*
      mutable_ballooninfolist();

  // repeated int32 destroyBalloonIDList = 3;
  inline int destroyballoonidlist_size() const;
  inline void clear_destroyballoonidlist();
  static const int kDestroyBalloonIDListFieldNumber = 3;
  inline ::google::protobuf::int32 destroyballoonidlist(int index) const;
  inline void set_destroyballoonidlist(int index, ::google::protobuf::int32 value);
  inline void add_destroyballoonidlist(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      destroyballoonidlist() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_destroyballoonidlist();

  // repeated .message.GameGuide.BattleLayout.Move moveList = 4;
  inline int movelist_size() const;
  inline void clear_movelist();
  static const int kMoveListFieldNumber = 4;
  inline const ::message::GameGuide_BattleLayout_Move& movelist(int index) const;
  inline ::message::GameGuide_BattleLayout_Move* mutable_movelist(int index);
  inline ::message::GameGuide_BattleLayout_Move* add_movelist();
  inline const ::google::protobuf::RepeatedPtrField< ::message::GameGuide_BattleLayout_Move >&
      movelist() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::GameGuide_BattleLayout_Move >*
      mutable_movelist();

  // @@protoc_insertion_point(class_scope:message.GameGuide.BattleLayout)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::RepeatedPtrField< ::message::GameGuide_BattleLayout_BalloonInfo > ballooninfolist_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > destroyballoonidlist_;
  ::google::protobuf::RepeatedPtrField< ::message::GameGuide_BattleLayout_Move > movelist_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_HSGameGuide_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_HSGameGuide_2eproto();
  #endif
  friend void protobuf_AssignDesc_HSGameGuide_2eproto();
  friend void protobuf_ShutdownFile_HSGameGuide_2eproto();

  void InitAsDefaultInstance();
  static GameGuide_BattleLayout* default_instance_;
};
// -------------------------------------------------------------------

class GameGuide : public ::google::protobuf::MessageLite {
 public:
  GameGuide();
  virtual ~GameGuide();

  GameGuide(const GameGuide& from);

  inline GameGuide& operator=(const GameGuide& from) {
    CopyFrom(from);
    return *this;
  }

  static const GameGuide& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GameGuide* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GameGuide* other);

  // implements Message ----------------------------------------------

  GameGuide* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameGuide& from);
  void MergeFrom(const GameGuide& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef GameGuide_Guide Guide;
  typedef GameGuide_BattleLayout BattleLayout;

  // accessors -------------------------------------------------------

  // repeated .message.GameGuide.Guide guideList = 1;
  inline int guidelist_size() const;
  inline void clear_guidelist();
  static const int kGuideListFieldNumber = 1;
  inline const ::message::GameGuide_Guide& guidelist(int index) const;
  inline ::message::GameGuide_Guide* mutable_guidelist(int index);
  inline ::message::GameGuide_Guide* add_guidelist();
  inline const ::google::protobuf::RepeatedPtrField< ::message::GameGuide_Guide >&
      guidelist() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::GameGuide_Guide >*
      mutable_guidelist();

  // repeated .message.GameGuide.BattleLayout battleLayoutList = 2;
  inline int battlelayoutlist_size() const;
  inline void clear_battlelayoutlist();
  static const int kBattleLayoutListFieldNumber = 2;
  inline const ::message::GameGuide_BattleLayout& battlelayoutlist(int index) const;
  inline ::message::GameGuide_BattleLayout* mutable_battlelayoutlist(int index);
  inline ::message::GameGuide_BattleLayout* add_battlelayoutlist();
  inline const ::google::protobuf::RepeatedPtrField< ::message::GameGuide_BattleLayout >&
      battlelayoutlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::GameGuide_BattleLayout >*
      mutable_battlelayoutlist();

  // @@protoc_insertion_point(class_scope:message.GameGuide)
 private:

  ::google::protobuf::RepeatedPtrField< ::message::GameGuide_Guide > guidelist_;
  ::google::protobuf::RepeatedPtrField< ::message::GameGuide_BattleLayout > battlelayoutlist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_HSGameGuide_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_HSGameGuide_2eproto();
  #endif
  friend void protobuf_AssignDesc_HSGameGuide_2eproto();
  friend void protobuf_ShutdownFile_HSGameGuide_2eproto();

  void InitAsDefaultInstance();
  static GameGuide* default_instance_;
};
// ===================================================================


// ===================================================================

// GameGuide_Guide_Point

// required float x = 1;
inline bool GameGuide_Guide_Point::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameGuide_Guide_Point::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameGuide_Guide_Point::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameGuide_Guide_Point::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float GameGuide_Guide_Point::x() const {
  return x_;
}
inline void GameGuide_Guide_Point::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 2;
inline bool GameGuide_Guide_Point::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameGuide_Guide_Point::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameGuide_Guide_Point::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameGuide_Guide_Point::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float GameGuide_Guide_Point::y() const {
  return y_;
}
inline void GameGuide_Guide_Point::set_y(float value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// GameGuide_Guide

// required int32 id = 1;
inline bool GameGuide_Guide::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameGuide_Guide::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameGuide_Guide::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameGuide_Guide::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 GameGuide_Guide::id() const {
  return id_;
}
inline void GameGuide_Guide::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required bool isInterceptTouch = 2;
inline bool GameGuide_Guide::has_isintercepttouch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameGuide_Guide::set_has_isintercepttouch() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameGuide_Guide::clear_has_isintercepttouch() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameGuide_Guide::clear_isintercepttouch() {
  isintercepttouch_ = false;
  clear_has_isintercepttouch();
}
inline bool GameGuide_Guide::isintercepttouch() const {
  return isintercepttouch_;
}
inline void GameGuide_Guide::set_isintercepttouch(bool value) {
  set_has_isintercepttouch();
  isintercepttouch_ = value;
}

// required bool isShowMask = 3;
inline bool GameGuide_Guide::has_isshowmask() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameGuide_Guide::set_has_isshowmask() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameGuide_Guide::clear_has_isshowmask() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameGuide_Guide::clear_isshowmask() {
  isshowmask_ = false;
  clear_has_isshowmask();
}
inline bool GameGuide_Guide::isshowmask() const {
  return isshowmask_;
}
inline void GameGuide_Guide::set_isshowmask(bool value) {
  set_has_isshowmask();
  isshowmask_ = value;
}

// required bool isShowHole = 4;
inline bool GameGuide_Guide::has_isshowhole() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameGuide_Guide::set_has_isshowhole() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameGuide_Guide::clear_has_isshowhole() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameGuide_Guide::clear_isshowhole() {
  isshowhole_ = false;
  clear_has_isshowhole();
}
inline bool GameGuide_Guide::isshowhole() const {
  return isshowhole_;
}
inline void GameGuide_Guide::set_isshowhole(bool value) {
  set_has_isshowhole();
  isshowhole_ = value;
}

// required bool isPause = 5;
inline bool GameGuide_Guide::has_ispause() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameGuide_Guide::set_has_ispause() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameGuide_Guide::clear_has_ispause() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameGuide_Guide::clear_ispause() {
  ispause_ = false;
  clear_has_ispause();
}
inline bool GameGuide_Guide::ispause() const {
  return ispause_;
}
inline void GameGuide_Guide::set_ispause(bool value) {
  set_has_ispause();
  ispause_ = value;
}

// optional .message.GameGuide.Guide.ModeType modeType = 6;
inline bool GameGuide_Guide::has_modetype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GameGuide_Guide::set_has_modetype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GameGuide_Guide::clear_has_modetype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GameGuide_Guide::clear_modetype() {
  modetype_ = 0;
  clear_has_modetype();
}
inline ::message::GameGuide_Guide_ModeType GameGuide_Guide::modetype() const {
  return static_cast< ::message::GameGuide_Guide_ModeType >(modetype_);
}
inline void GameGuide_Guide::set_modetype(::message::GameGuide_Guide_ModeType value) {
  assert(::message::GameGuide_Guide_ModeType_IsValid(value));
  set_has_modetype();
  modetype_ = value;
}

// optional .message.GameGuide.Guide.Point modePos = 7;
inline bool GameGuide_Guide::has_modepos() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GameGuide_Guide::set_has_modepos() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GameGuide_Guide::clear_has_modepos() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GameGuide_Guide::clear_modepos() {
  if (modepos_ != NULL) modepos_->::message::GameGuide_Guide_Point::Clear();
  clear_has_modepos();
}
inline const ::message::GameGuide_Guide_Point& GameGuide_Guide::modepos() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return modepos_ != NULL ? *modepos_ : *default_instance().modepos_;
#else
  return modepos_ != NULL ? *modepos_ : *default_instance_->modepos_;
#endif
}
inline ::message::GameGuide_Guide_Point* GameGuide_Guide::mutable_modepos() {
  set_has_modepos();
  if (modepos_ == NULL) modepos_ = new ::message::GameGuide_Guide_Point;
  return modepos_;
}
inline ::message::GameGuide_Guide_Point* GameGuide_Guide::release_modepos() {
  clear_has_modepos();
  ::message::GameGuide_Guide_Point* temp = modepos_;
  modepos_ = NULL;
  return temp;
}
inline void GameGuide_Guide::set_allocated_modepos(::message::GameGuide_Guide_Point* modepos) {
  delete modepos_;
  modepos_ = modepos;
  if (modepos) {
    set_has_modepos();
  } else {
    clear_has_modepos();
  }
}

// optional float w = 8;
inline bool GameGuide_Guide::has_w() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GameGuide_Guide::set_has_w() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GameGuide_Guide::clear_has_w() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GameGuide_Guide::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline float GameGuide_Guide::w() const {
  return w_;
}
inline void GameGuide_Guide::set_w(float value) {
  set_has_w();
  w_ = value;
}

// optional float h = 9;
inline bool GameGuide_Guide::has_h() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GameGuide_Guide::set_has_h() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GameGuide_Guide::clear_has_h() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GameGuide_Guide::clear_h() {
  h_ = 0;
  clear_has_h();
}
inline float GameGuide_Guide::h() const {
  return h_;
}
inline void GameGuide_Guide::set_h(float value) {
  set_has_h();
  h_ = value;
}

// optional .message.GameGuide.Guide.Point indicationSignPos = 10;
inline bool GameGuide_Guide::has_indicationsignpos() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GameGuide_Guide::set_has_indicationsignpos() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GameGuide_Guide::clear_has_indicationsignpos() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GameGuide_Guide::clear_indicationsignpos() {
  if (indicationsignpos_ != NULL) indicationsignpos_->::message::GameGuide_Guide_Point::Clear();
  clear_has_indicationsignpos();
}
inline const ::message::GameGuide_Guide_Point& GameGuide_Guide::indicationsignpos() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return indicationsignpos_ != NULL ? *indicationsignpos_ : *default_instance().indicationsignpos_;
#else
  return indicationsignpos_ != NULL ? *indicationsignpos_ : *default_instance_->indicationsignpos_;
#endif
}
inline ::message::GameGuide_Guide_Point* GameGuide_Guide::mutable_indicationsignpos() {
  set_has_indicationsignpos();
  if (indicationsignpos_ == NULL) indicationsignpos_ = new ::message::GameGuide_Guide_Point;
  return indicationsignpos_;
}
inline ::message::GameGuide_Guide_Point* GameGuide_Guide::release_indicationsignpos() {
  clear_has_indicationsignpos();
  ::message::GameGuide_Guide_Point* temp = indicationsignpos_;
  indicationsignpos_ = NULL;
  return temp;
}
inline void GameGuide_Guide::set_allocated_indicationsignpos(::message::GameGuide_Guide_Point* indicationsignpos) {
  delete indicationsignpos_;
  indicationsignpos_ = indicationsignpos;
  if (indicationsignpos) {
    set_has_indicationsignpos();
  } else {
    clear_has_indicationsignpos();
  }
}

// optional .message.GameGuide.Guide.MirrorType mirror = 11;
inline bool GameGuide_Guide::has_mirror() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GameGuide_Guide::set_has_mirror() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GameGuide_Guide::clear_has_mirror() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GameGuide_Guide::clear_mirror() {
  mirror_ = 0;
  clear_has_mirror();
}
inline ::message::GameGuide_Guide_MirrorType GameGuide_Guide::mirror() const {
  return static_cast< ::message::GameGuide_Guide_MirrorType >(mirror_);
}
inline void GameGuide_Guide::set_mirror(::message::GameGuide_Guide_MirrorType value) {
  assert(::message::GameGuide_Guide_MirrorType_IsValid(value));
  set_has_mirror();
  mirror_ = value;
}

// optional float rotate = 12 [default = 0];
inline bool GameGuide_Guide::has_rotate() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GameGuide_Guide::set_has_rotate() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GameGuide_Guide::clear_has_rotate() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GameGuide_Guide::clear_rotate() {
  rotate_ = 0;
  clear_has_rotate();
}
inline float GameGuide_Guide::rotate() const {
  return rotate_;
}
inline void GameGuide_Guide::set_rotate(float value) {
  set_has_rotate();
  rotate_ = value;
}

// optional .message.GameGuide.Guide.Point describeFramePos = 13;
inline bool GameGuide_Guide::has_describeframepos() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GameGuide_Guide::set_has_describeframepos() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GameGuide_Guide::clear_has_describeframepos() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GameGuide_Guide::clear_describeframepos() {
  if (describeframepos_ != NULL) describeframepos_->::message::GameGuide_Guide_Point::Clear();
  clear_has_describeframepos();
}
inline const ::message::GameGuide_Guide_Point& GameGuide_Guide::describeframepos() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return describeframepos_ != NULL ? *describeframepos_ : *default_instance().describeframepos_;
#else
  return describeframepos_ != NULL ? *describeframepos_ : *default_instance_->describeframepos_;
#endif
}
inline ::message::GameGuide_Guide_Point* GameGuide_Guide::mutable_describeframepos() {
  set_has_describeframepos();
  if (describeframepos_ == NULL) describeframepos_ = new ::message::GameGuide_Guide_Point;
  return describeframepos_;
}
inline ::message::GameGuide_Guide_Point* GameGuide_Guide::release_describeframepos() {
  clear_has_describeframepos();
  ::message::GameGuide_Guide_Point* temp = describeframepos_;
  describeframepos_ = NULL;
  return temp;
}
inline void GameGuide_Guide::set_allocated_describeframepos(::message::GameGuide_Guide_Point* describeframepos) {
  delete describeframepos_;
  describeframepos_ = describeframepos;
  if (describeframepos) {
    set_has_describeframepos();
  } else {
    clear_has_describeframepos();
  }
}

// optional string describe = 14 [default = ""];
inline bool GameGuide_Guide::has_describe() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GameGuide_Guide::set_has_describe() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GameGuide_Guide::clear_has_describe() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GameGuide_Guide::clear_describe() {
  if (describe_ != &::google::protobuf::internal::kEmptyString) {
    describe_->clear();
  }
  clear_has_describe();
}
inline const ::std::string& GameGuide_Guide::describe() const {
  return *describe_;
}
inline void GameGuide_Guide::set_describe(const ::std::string& value) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(value);
}
inline void GameGuide_Guide::set_describe(const char* value) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(value);
}
inline void GameGuide_Guide::set_describe(const char* value, size_t size) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameGuide_Guide::mutable_describe() {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  return describe_;
}
inline ::std::string* GameGuide_Guide::release_describe() {
  clear_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = describe_;
    describe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameGuide_Guide::set_allocated_describe(::std::string* describe) {
  if (describe_ != &::google::protobuf::internal::kEmptyString) {
    delete describe_;
  }
  if (describe) {
    set_has_describe();
    describe_ = describe;
  } else {
    clear_has_describe();
    describe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GameGuide_BattleLayout_BalloonInfo

// required int32 id = 1;
inline bool GameGuide_BattleLayout_BalloonInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameGuide_BattleLayout_BalloonInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameGuide_BattleLayout_BalloonInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameGuide_BattleLayout_BalloonInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 GameGuide_BattleLayout_BalloonInfo::id() const {
  return id_;
}
inline void GameGuide_BattleLayout_BalloonInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required float x = 2;
inline bool GameGuide_BattleLayout_BalloonInfo::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameGuide_BattleLayout_BalloonInfo::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameGuide_BattleLayout_BalloonInfo::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameGuide_BattleLayout_BalloonInfo::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float GameGuide_BattleLayout_BalloonInfo::x() const {
  return x_;
}
inline void GameGuide_BattleLayout_BalloonInfo::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 3;
inline bool GameGuide_BattleLayout_BalloonInfo::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameGuide_BattleLayout_BalloonInfo::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameGuide_BattleLayout_BalloonInfo::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameGuide_BattleLayout_BalloonInfo::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float GameGuide_BattleLayout_BalloonInfo::y() const {
  return y_;
}
inline void GameGuide_BattleLayout_BalloonInfo::set_y(float value) {
  set_has_y();
  y_ = value;
}

// required int32 color = 4;
inline bool GameGuide_BattleLayout_BalloonInfo::has_color() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameGuide_BattleLayout_BalloonInfo::set_has_color() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameGuide_BattleLayout_BalloonInfo::clear_has_color() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameGuide_BattleLayout_BalloonInfo::clear_color() {
  color_ = 0;
  clear_has_color();
}
inline ::google::protobuf::int32 GameGuide_BattleLayout_BalloonInfo::color() const {
  return color_;
}
inline void GameGuide_BattleLayout_BalloonInfo::set_color(::google::protobuf::int32 value) {
  set_has_color();
  color_ = value;
}

// -------------------------------------------------------------------

// GameGuide_BattleLayout_Move

// required int32 beginID = 1;
inline bool GameGuide_BattleLayout_Move::has_beginid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameGuide_BattleLayout_Move::set_has_beginid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameGuide_BattleLayout_Move::clear_has_beginid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameGuide_BattleLayout_Move::clear_beginid() {
  beginid_ = 0;
  clear_has_beginid();
}
inline ::google::protobuf::int32 GameGuide_BattleLayout_Move::beginid() const {
  return beginid_;
}
inline void GameGuide_BattleLayout_Move::set_beginid(::google::protobuf::int32 value) {
  set_has_beginid();
  beginid_ = value;
}

// required int32 endID = 2;
inline bool GameGuide_BattleLayout_Move::has_endid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameGuide_BattleLayout_Move::set_has_endid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameGuide_BattleLayout_Move::clear_has_endid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameGuide_BattleLayout_Move::clear_endid() {
  endid_ = 0;
  clear_has_endid();
}
inline ::google::protobuf::int32 GameGuide_BattleLayout_Move::endid() const {
  return endid_;
}
inline void GameGuide_BattleLayout_Move::set_endid(::google::protobuf::int32 value) {
  set_has_endid();
  endid_ = value;
}

// -------------------------------------------------------------------

// GameGuide_BattleLayout

// required int32 id = 1;
inline bool GameGuide_BattleLayout::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameGuide_BattleLayout::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameGuide_BattleLayout::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameGuide_BattleLayout::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 GameGuide_BattleLayout::id() const {
  return id_;
}
inline void GameGuide_BattleLayout::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// repeated .message.GameGuide.BattleLayout.BalloonInfo balloonInfoList = 2;
inline int GameGuide_BattleLayout::ballooninfolist_size() const {
  return ballooninfolist_.size();
}
inline void GameGuide_BattleLayout::clear_ballooninfolist() {
  ballooninfolist_.Clear();
}
inline const ::message::GameGuide_BattleLayout_BalloonInfo& GameGuide_BattleLayout::ballooninfolist(int index) const {
  return ballooninfolist_.Get(index);
}
inline ::message::GameGuide_BattleLayout_BalloonInfo* GameGuide_BattleLayout::mutable_ballooninfolist(int index) {
  return ballooninfolist_.Mutable(index);
}
inline ::message::GameGuide_BattleLayout_BalloonInfo* GameGuide_BattleLayout::add_ballooninfolist() {
  return ballooninfolist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::GameGuide_BattleLayout_BalloonInfo >&
GameGuide_BattleLayout::ballooninfolist() const {
  return ballooninfolist_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::GameGuide_BattleLayout_BalloonInfo >*
GameGuide_BattleLayout::mutable_ballooninfolist() {
  return &ballooninfolist_;
}

// repeated int32 destroyBalloonIDList = 3;
inline int GameGuide_BattleLayout::destroyballoonidlist_size() const {
  return destroyballoonidlist_.size();
}
inline void GameGuide_BattleLayout::clear_destroyballoonidlist() {
  destroyballoonidlist_.Clear();
}
inline ::google::protobuf::int32 GameGuide_BattleLayout::destroyballoonidlist(int index) const {
  return destroyballoonidlist_.Get(index);
}
inline void GameGuide_BattleLayout::set_destroyballoonidlist(int index, ::google::protobuf::int32 value) {
  destroyballoonidlist_.Set(index, value);
}
inline void GameGuide_BattleLayout::add_destroyballoonidlist(::google::protobuf::int32 value) {
  destroyballoonidlist_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GameGuide_BattleLayout::destroyballoonidlist() const {
  return destroyballoonidlist_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GameGuide_BattleLayout::mutable_destroyballoonidlist() {
  return &destroyballoonidlist_;
}

// repeated .message.GameGuide.BattleLayout.Move moveList = 4;
inline int GameGuide_BattleLayout::movelist_size() const {
  return movelist_.size();
}
inline void GameGuide_BattleLayout::clear_movelist() {
  movelist_.Clear();
}
inline const ::message::GameGuide_BattleLayout_Move& GameGuide_BattleLayout::movelist(int index) const {
  return movelist_.Get(index);
}
inline ::message::GameGuide_BattleLayout_Move* GameGuide_BattleLayout::mutable_movelist(int index) {
  return movelist_.Mutable(index);
}
inline ::message::GameGuide_BattleLayout_Move* GameGuide_BattleLayout::add_movelist() {
  return movelist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::GameGuide_BattleLayout_Move >&
GameGuide_BattleLayout::movelist() const {
  return movelist_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::GameGuide_BattleLayout_Move >*
GameGuide_BattleLayout::mutable_movelist() {
  return &movelist_;
}

// -------------------------------------------------------------------

// GameGuide

// repeated .message.GameGuide.Guide guideList = 1;
inline int GameGuide::guidelist_size() const {
  return guidelist_.size();
}
inline void GameGuide::clear_guidelist() {
  guidelist_.Clear();
}
inline const ::message::GameGuide_Guide& GameGuide::guidelist(int index) const {
  return guidelist_.Get(index);
}
inline ::message::GameGuide_Guide* GameGuide::mutable_guidelist(int index) {
  return guidelist_.Mutable(index);
}
inline ::message::GameGuide_Guide* GameGuide::add_guidelist() {
  return guidelist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::GameGuide_Guide >&
GameGuide::guidelist() const {
  return guidelist_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::GameGuide_Guide >*
GameGuide::mutable_guidelist() {
  return &guidelist_;
}

// repeated .message.GameGuide.BattleLayout battleLayoutList = 2;
inline int GameGuide::battlelayoutlist_size() const {
  return battlelayoutlist_.size();
}
inline void GameGuide::clear_battlelayoutlist() {
  battlelayoutlist_.Clear();
}
inline const ::message::GameGuide_BattleLayout& GameGuide::battlelayoutlist(int index) const {
  return battlelayoutlist_.Get(index);
}
inline ::message::GameGuide_BattleLayout* GameGuide::mutable_battlelayoutlist(int index) {
  return battlelayoutlist_.Mutable(index);
}
inline ::message::GameGuide_BattleLayout* GameGuide::add_battlelayoutlist() {
  return battlelayoutlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::GameGuide_BattleLayout >&
GameGuide::battlelayoutlist() const {
  return battlelayoutlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::GameGuide_BattleLayout >*
GameGuide::mutable_battlelayoutlist() {
  return &battlelayoutlist_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace message

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_HSGameGuide_2eproto__INCLUDED
