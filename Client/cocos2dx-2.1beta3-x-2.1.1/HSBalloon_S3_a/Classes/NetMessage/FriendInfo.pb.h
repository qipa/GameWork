// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: FriendInfo.proto

#ifndef PROTOBUF_FriendInfo_2eproto__INCLUDED
#define PROTOBUF_FriendInfo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace message {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_FriendInfo_2eproto();
void protobuf_AssignDesc_FriendInfo_2eproto();
void protobuf_ShutdownFile_FriendInfo_2eproto();

class FriendInfoRequest;
class FriendInfoResponse;
class FriendInfoResponse_PlayerInfoList;
class FriendInfoResponse_PlayerInfo;

enum FriendInfoResponse_PlayerInfo_State {
  FriendInfoResponse_PlayerInfo_State_State_Online = 0,
  FriendInfoResponse_PlayerInfo_State_State_Busy = 1,
  FriendInfoResponse_PlayerInfo_State_State_Offline = 2
};
bool FriendInfoResponse_PlayerInfo_State_IsValid(int value);
const FriendInfoResponse_PlayerInfo_State FriendInfoResponse_PlayerInfo_State_State_MIN = FriendInfoResponse_PlayerInfo_State_State_Online;
const FriendInfoResponse_PlayerInfo_State FriendInfoResponse_PlayerInfo_State_State_MAX = FriendInfoResponse_PlayerInfo_State_State_Offline;
const int FriendInfoResponse_PlayerInfo_State_State_ARRAYSIZE = FriendInfoResponse_PlayerInfo_State_State_MAX + 1;

// ===================================================================

class FriendInfoRequest : public ::google::protobuf::MessageLite {
 public:
  FriendInfoRequest();
  virtual ~FriendInfoRequest();

  FriendInfoRequest(const FriendInfoRequest& from);

  inline FriendInfoRequest& operator=(const FriendInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const FriendInfoRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FriendInfoRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FriendInfoRequest* other);

  // implements Message ----------------------------------------------

  FriendInfoRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FriendInfoRequest& from);
  void MergeFrom(const FriendInfoRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:message.FriendInfoRequest)
 private:


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FriendInfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FriendInfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_FriendInfo_2eproto();
  friend void protobuf_ShutdownFile_FriendInfo_2eproto();

  void InitAsDefaultInstance();
  static FriendInfoRequest* default_instance_;
};
// -------------------------------------------------------------------

class FriendInfoResponse_PlayerInfoList : public ::google::protobuf::MessageLite {
 public:
  FriendInfoResponse_PlayerInfoList();
  virtual ~FriendInfoResponse_PlayerInfoList();

  FriendInfoResponse_PlayerInfoList(const FriendInfoResponse_PlayerInfoList& from);

  inline FriendInfoResponse_PlayerInfoList& operator=(const FriendInfoResponse_PlayerInfoList& from) {
    CopyFrom(from);
    return *this;
  }

  static const FriendInfoResponse_PlayerInfoList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FriendInfoResponse_PlayerInfoList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FriendInfoResponse_PlayerInfoList* other);

  // implements Message ----------------------------------------------

  FriendInfoResponse_PlayerInfoList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FriendInfoResponse_PlayerInfoList& from);
  void MergeFrom(const FriendInfoResponse_PlayerInfoList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 maxCount = 1;
  inline bool has_maxcount() const;
  inline void clear_maxcount();
  static const int kMaxCountFieldNumber = 1;
  inline ::google::protobuf::int32 maxcount() const;
  inline void set_maxcount(::google::protobuf::int32 value);

  // repeated .message.FriendInfoResponse.PlayerInfo list = 2;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 2;
  inline const ::message::FriendInfoResponse_PlayerInfo& list(int index) const;
  inline ::message::FriendInfoResponse_PlayerInfo* mutable_list(int index);
  inline ::message::FriendInfoResponse_PlayerInfo* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::message::FriendInfoResponse_PlayerInfo >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::FriendInfoResponse_PlayerInfo >*
      mutable_list();

  // @@protoc_insertion_point(class_scope:message.FriendInfoResponse.PlayerInfoList)
 private:
  inline void set_has_maxcount();
  inline void clear_has_maxcount();

  ::google::protobuf::RepeatedPtrField< ::message::FriendInfoResponse_PlayerInfo > list_;
  ::google::protobuf::int32 maxcount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FriendInfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FriendInfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_FriendInfo_2eproto();
  friend void protobuf_ShutdownFile_FriendInfo_2eproto();

  void InitAsDefaultInstance();
  static FriendInfoResponse_PlayerInfoList* default_instance_;
};
// -------------------------------------------------------------------

class FriendInfoResponse_PlayerInfo : public ::google::protobuf::MessageLite {
 public:
  FriendInfoResponse_PlayerInfo();
  virtual ~FriendInfoResponse_PlayerInfo();

  FriendInfoResponse_PlayerInfo(const FriendInfoResponse_PlayerInfo& from);

  inline FriendInfoResponse_PlayerInfo& operator=(const FriendInfoResponse_PlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const FriendInfoResponse_PlayerInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FriendInfoResponse_PlayerInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FriendInfoResponse_PlayerInfo* other);

  // implements Message ----------------------------------------------

  FriendInfoResponse_PlayerInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FriendInfoResponse_PlayerInfo& from);
  void MergeFrom(const FriendInfoResponse_PlayerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef FriendInfoResponse_PlayerInfo_State State;
  static const State State_Online = FriendInfoResponse_PlayerInfo_State_State_Online;
  static const State State_Busy = FriendInfoResponse_PlayerInfo_State_State_Busy;
  static const State State_Offline = FriendInfoResponse_PlayerInfo_State_State_Offline;
  static inline bool State_IsValid(int value) {
    return FriendInfoResponse_PlayerInfo_State_IsValid(value);
  }
  static const State State_MIN =
    FriendInfoResponse_PlayerInfo_State_State_MIN;
  static const State State_MAX =
    FriendInfoResponse_PlayerInfo_State_State_MAX;
  static const int State_ARRAYSIZE =
    FriendInfoResponse_PlayerInfo_State_State_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required string friendUUID = 1;
  inline bool has_frienduuid() const;
  inline void clear_frienduuid();
  static const int kFriendUUIDFieldNumber = 1;
  inline const ::std::string& frienduuid() const;
  inline void set_frienduuid(const ::std::string& value);
  inline void set_frienduuid(const char* value);
  inline void set_frienduuid(const char* value, size_t size);
  inline ::std::string* mutable_frienduuid();
  inline ::std::string* release_frienduuid();
  inline void set_allocated_frienduuid(::std::string* frienduuid);

  // required string friendName = 2;
  inline bool has_friendname() const;
  inline void clear_friendname();
  static const int kFriendNameFieldNumber = 2;
  inline const ::std::string& friendname() const;
  inline void set_friendname(const ::std::string& value);
  inline void set_friendname(const char* value);
  inline void set_friendname(const char* value, size_t size);
  inline ::std::string* mutable_friendname();
  inline ::std::string* release_friendname();
  inline void set_allocated_friendname(::std::string* friendname);

  // required int32 gameScore = 3;
  inline bool has_gamescore() const;
  inline void clear_gamescore();
  static const int kGameScoreFieldNumber = 3;
  inline ::google::protobuf::int32 gamescore() const;
  inline void set_gamescore(::google::protobuf::int32 value);

  // required int32 money = 4;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 4;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);

  // required string headIcon = 5;
  inline bool has_headicon() const;
  inline void clear_headicon();
  static const int kHeadIconFieldNumber = 5;
  inline const ::std::string& headicon() const;
  inline void set_headicon(const ::std::string& value);
  inline void set_headicon(const char* value);
  inline void set_headicon(const char* value, size_t size);
  inline ::std::string* mutable_headicon();
  inline ::std::string* release_headicon();
  inline void set_allocated_headicon(::std::string* headicon);

  // required .message.FriendInfoResponse.PlayerInfo.State state = 6;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 6;
  inline ::message::FriendInfoResponse_PlayerInfo_State state() const;
  inline void set_state(::message::FriendInfoResponse_PlayerInfo_State value);

  // repeated string email = 7;
  inline int email_size() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 7;
  inline const ::std::string& email(int index) const;
  inline ::std::string* mutable_email(int index);
  inline void set_email(int index, const ::std::string& value);
  inline void set_email(int index, const char* value);
  inline void set_email(int index, const char* value, size_t size);
  inline ::std::string* add_email();
  inline void add_email(const ::std::string& value);
  inline void add_email(const char* value);
  inline void add_email(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& email() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_email();

  // @@protoc_insertion_point(class_scope:message.FriendInfoResponse.PlayerInfo)
 private:
  inline void set_has_frienduuid();
  inline void clear_has_frienduuid();
  inline void set_has_friendname();
  inline void clear_has_friendname();
  inline void set_has_gamescore();
  inline void clear_has_gamescore();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_headicon();
  inline void clear_has_headicon();
  inline void set_has_state();
  inline void clear_has_state();

  ::std::string* frienduuid_;
  ::std::string* friendname_;
  ::google::protobuf::int32 gamescore_;
  ::google::protobuf::int32 money_;
  ::std::string* headicon_;
  ::google::protobuf::RepeatedPtrField< ::std::string> email_;
  int state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FriendInfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FriendInfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_FriendInfo_2eproto();
  friend void protobuf_ShutdownFile_FriendInfo_2eproto();

  void InitAsDefaultInstance();
  static FriendInfoResponse_PlayerInfo* default_instance_;
};
// -------------------------------------------------------------------

class FriendInfoResponse : public ::google::protobuf::MessageLite {
 public:
  FriendInfoResponse();
  virtual ~FriendInfoResponse();

  FriendInfoResponse(const FriendInfoResponse& from);

  inline FriendInfoResponse& operator=(const FriendInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const FriendInfoResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FriendInfoResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FriendInfoResponse* other);

  // implements Message ----------------------------------------------

  FriendInfoResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FriendInfoResponse& from);
  void MergeFrom(const FriendInfoResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef FriendInfoResponse_PlayerInfoList PlayerInfoList;
  typedef FriendInfoResponse_PlayerInfo PlayerInfo;

  // accessors -------------------------------------------------------

  // optional .message.FriendInfoResponse.PlayerInfoList friendList = 1;
  inline bool has_friendlist() const;
  inline void clear_friendlist();
  static const int kFriendListFieldNumber = 1;
  inline const ::message::FriendInfoResponse_PlayerInfoList& friendlist() const;
  inline ::message::FriendInfoResponse_PlayerInfoList* mutable_friendlist();
  inline ::message::FriendInfoResponse_PlayerInfoList* release_friendlist();
  inline void set_allocated_friendlist(::message::FriendInfoResponse_PlayerInfoList* friendlist);

  // optional .message.FriendInfoResponse.PlayerInfoList enemyList = 2;
  inline bool has_enemylist() const;
  inline void clear_enemylist();
  static const int kEnemyListFieldNumber = 2;
  inline const ::message::FriendInfoResponse_PlayerInfoList& enemylist() const;
  inline ::message::FriendInfoResponse_PlayerInfoList* mutable_enemylist();
  inline ::message::FriendInfoResponse_PlayerInfoList* release_enemylist();
  inline void set_allocated_enemylist(::message::FriendInfoResponse_PlayerInfoList* enemylist);

  // @@protoc_insertion_point(class_scope:message.FriendInfoResponse)
 private:
  inline void set_has_friendlist();
  inline void clear_has_friendlist();
  inline void set_has_enemylist();
  inline void clear_has_enemylist();

  ::message::FriendInfoResponse_PlayerInfoList* friendlist_;
  ::message::FriendInfoResponse_PlayerInfoList* enemylist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FriendInfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FriendInfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_FriendInfo_2eproto();
  friend void protobuf_ShutdownFile_FriendInfo_2eproto();

  void InitAsDefaultInstance();
  static FriendInfoResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// FriendInfoRequest

// -------------------------------------------------------------------

// FriendInfoResponse_PlayerInfoList

// required int32 maxCount = 1;
inline bool FriendInfoResponse_PlayerInfoList::has_maxcount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FriendInfoResponse_PlayerInfoList::set_has_maxcount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FriendInfoResponse_PlayerInfoList::clear_has_maxcount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FriendInfoResponse_PlayerInfoList::clear_maxcount() {
  maxcount_ = 0;
  clear_has_maxcount();
}
inline ::google::protobuf::int32 FriendInfoResponse_PlayerInfoList::maxcount() const {
  return maxcount_;
}
inline void FriendInfoResponse_PlayerInfoList::set_maxcount(::google::protobuf::int32 value) {
  set_has_maxcount();
  maxcount_ = value;
}

// repeated .message.FriendInfoResponse.PlayerInfo list = 2;
inline int FriendInfoResponse_PlayerInfoList::list_size() const {
  return list_.size();
}
inline void FriendInfoResponse_PlayerInfoList::clear_list() {
  list_.Clear();
}
inline const ::message::FriendInfoResponse_PlayerInfo& FriendInfoResponse_PlayerInfoList::list(int index) const {
  return list_.Get(index);
}
inline ::message::FriendInfoResponse_PlayerInfo* FriendInfoResponse_PlayerInfoList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::message::FriendInfoResponse_PlayerInfo* FriendInfoResponse_PlayerInfoList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::FriendInfoResponse_PlayerInfo >&
FriendInfoResponse_PlayerInfoList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::FriendInfoResponse_PlayerInfo >*
FriendInfoResponse_PlayerInfoList::mutable_list() {
  return &list_;
}

// -------------------------------------------------------------------

// FriendInfoResponse_PlayerInfo

// required string friendUUID = 1;
inline bool FriendInfoResponse_PlayerInfo::has_frienduuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FriendInfoResponse_PlayerInfo::set_has_frienduuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FriendInfoResponse_PlayerInfo::clear_has_frienduuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FriendInfoResponse_PlayerInfo::clear_frienduuid() {
  if (frienduuid_ != &::google::protobuf::internal::kEmptyString) {
    frienduuid_->clear();
  }
  clear_has_frienduuid();
}
inline const ::std::string& FriendInfoResponse_PlayerInfo::frienduuid() const {
  return *frienduuid_;
}
inline void FriendInfoResponse_PlayerInfo::set_frienduuid(const ::std::string& value) {
  set_has_frienduuid();
  if (frienduuid_ == &::google::protobuf::internal::kEmptyString) {
    frienduuid_ = new ::std::string;
  }
  frienduuid_->assign(value);
}
inline void FriendInfoResponse_PlayerInfo::set_frienduuid(const char* value) {
  set_has_frienduuid();
  if (frienduuid_ == &::google::protobuf::internal::kEmptyString) {
    frienduuid_ = new ::std::string;
  }
  frienduuid_->assign(value);
}
inline void FriendInfoResponse_PlayerInfo::set_frienduuid(const char* value, size_t size) {
  set_has_frienduuid();
  if (frienduuid_ == &::google::protobuf::internal::kEmptyString) {
    frienduuid_ = new ::std::string;
  }
  frienduuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FriendInfoResponse_PlayerInfo::mutable_frienduuid() {
  set_has_frienduuid();
  if (frienduuid_ == &::google::protobuf::internal::kEmptyString) {
    frienduuid_ = new ::std::string;
  }
  return frienduuid_;
}
inline ::std::string* FriendInfoResponse_PlayerInfo::release_frienduuid() {
  clear_has_frienduuid();
  if (frienduuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = frienduuid_;
    frienduuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FriendInfoResponse_PlayerInfo::set_allocated_frienduuid(::std::string* frienduuid) {
  if (frienduuid_ != &::google::protobuf::internal::kEmptyString) {
    delete frienduuid_;
  }
  if (frienduuid) {
    set_has_frienduuid();
    frienduuid_ = frienduuid;
  } else {
    clear_has_frienduuid();
    frienduuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string friendName = 2;
inline bool FriendInfoResponse_PlayerInfo::has_friendname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FriendInfoResponse_PlayerInfo::set_has_friendname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FriendInfoResponse_PlayerInfo::clear_has_friendname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FriendInfoResponse_PlayerInfo::clear_friendname() {
  if (friendname_ != &::google::protobuf::internal::kEmptyString) {
    friendname_->clear();
  }
  clear_has_friendname();
}
inline const ::std::string& FriendInfoResponse_PlayerInfo::friendname() const {
  return *friendname_;
}
inline void FriendInfoResponse_PlayerInfo::set_friendname(const ::std::string& value) {
  set_has_friendname();
  if (friendname_ == &::google::protobuf::internal::kEmptyString) {
    friendname_ = new ::std::string;
  }
  friendname_->assign(value);
}
inline void FriendInfoResponse_PlayerInfo::set_friendname(const char* value) {
  set_has_friendname();
  if (friendname_ == &::google::protobuf::internal::kEmptyString) {
    friendname_ = new ::std::string;
  }
  friendname_->assign(value);
}
inline void FriendInfoResponse_PlayerInfo::set_friendname(const char* value, size_t size) {
  set_has_friendname();
  if (friendname_ == &::google::protobuf::internal::kEmptyString) {
    friendname_ = new ::std::string;
  }
  friendname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FriendInfoResponse_PlayerInfo::mutable_friendname() {
  set_has_friendname();
  if (friendname_ == &::google::protobuf::internal::kEmptyString) {
    friendname_ = new ::std::string;
  }
  return friendname_;
}
inline ::std::string* FriendInfoResponse_PlayerInfo::release_friendname() {
  clear_has_friendname();
  if (friendname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = friendname_;
    friendname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FriendInfoResponse_PlayerInfo::set_allocated_friendname(::std::string* friendname) {
  if (friendname_ != &::google::protobuf::internal::kEmptyString) {
    delete friendname_;
  }
  if (friendname) {
    set_has_friendname();
    friendname_ = friendname;
  } else {
    clear_has_friendname();
    friendname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 gameScore = 3;
inline bool FriendInfoResponse_PlayerInfo::has_gamescore() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FriendInfoResponse_PlayerInfo::set_has_gamescore() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FriendInfoResponse_PlayerInfo::clear_has_gamescore() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FriendInfoResponse_PlayerInfo::clear_gamescore() {
  gamescore_ = 0;
  clear_has_gamescore();
}
inline ::google::protobuf::int32 FriendInfoResponse_PlayerInfo::gamescore() const {
  return gamescore_;
}
inline void FriendInfoResponse_PlayerInfo::set_gamescore(::google::protobuf::int32 value) {
  set_has_gamescore();
  gamescore_ = value;
}

// required int32 money = 4;
inline bool FriendInfoResponse_PlayerInfo::has_money() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FriendInfoResponse_PlayerInfo::set_has_money() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FriendInfoResponse_PlayerInfo::clear_has_money() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FriendInfoResponse_PlayerInfo::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 FriendInfoResponse_PlayerInfo::money() const {
  return money_;
}
inline void FriendInfoResponse_PlayerInfo::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// required string headIcon = 5;
inline bool FriendInfoResponse_PlayerInfo::has_headicon() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FriendInfoResponse_PlayerInfo::set_has_headicon() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FriendInfoResponse_PlayerInfo::clear_has_headicon() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FriendInfoResponse_PlayerInfo::clear_headicon() {
  if (headicon_ != &::google::protobuf::internal::kEmptyString) {
    headicon_->clear();
  }
  clear_has_headicon();
}
inline const ::std::string& FriendInfoResponse_PlayerInfo::headicon() const {
  return *headicon_;
}
inline void FriendInfoResponse_PlayerInfo::set_headicon(const ::std::string& value) {
  set_has_headicon();
  if (headicon_ == &::google::protobuf::internal::kEmptyString) {
    headicon_ = new ::std::string;
  }
  headicon_->assign(value);
}
inline void FriendInfoResponse_PlayerInfo::set_headicon(const char* value) {
  set_has_headicon();
  if (headicon_ == &::google::protobuf::internal::kEmptyString) {
    headicon_ = new ::std::string;
  }
  headicon_->assign(value);
}
inline void FriendInfoResponse_PlayerInfo::set_headicon(const char* value, size_t size) {
  set_has_headicon();
  if (headicon_ == &::google::protobuf::internal::kEmptyString) {
    headicon_ = new ::std::string;
  }
  headicon_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FriendInfoResponse_PlayerInfo::mutable_headicon() {
  set_has_headicon();
  if (headicon_ == &::google::protobuf::internal::kEmptyString) {
    headicon_ = new ::std::string;
  }
  return headicon_;
}
inline ::std::string* FriendInfoResponse_PlayerInfo::release_headicon() {
  clear_has_headicon();
  if (headicon_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = headicon_;
    headicon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FriendInfoResponse_PlayerInfo::set_allocated_headicon(::std::string* headicon) {
  if (headicon_ != &::google::protobuf::internal::kEmptyString) {
    delete headicon_;
  }
  if (headicon) {
    set_has_headicon();
    headicon_ = headicon;
  } else {
    clear_has_headicon();
    headicon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .message.FriendInfoResponse.PlayerInfo.State state = 6;
inline bool FriendInfoResponse_PlayerInfo::has_state() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FriendInfoResponse_PlayerInfo::set_has_state() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FriendInfoResponse_PlayerInfo::clear_has_state() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FriendInfoResponse_PlayerInfo::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::message::FriendInfoResponse_PlayerInfo_State FriendInfoResponse_PlayerInfo::state() const {
  return static_cast< ::message::FriendInfoResponse_PlayerInfo_State >(state_);
}
inline void FriendInfoResponse_PlayerInfo::set_state(::message::FriendInfoResponse_PlayerInfo_State value) {
  assert(::message::FriendInfoResponse_PlayerInfo_State_IsValid(value));
  set_has_state();
  state_ = value;
}

// repeated string email = 7;
inline int FriendInfoResponse_PlayerInfo::email_size() const {
  return email_.size();
}
inline void FriendInfoResponse_PlayerInfo::clear_email() {
  email_.Clear();
}
inline const ::std::string& FriendInfoResponse_PlayerInfo::email(int index) const {
  return email_.Get(index);
}
inline ::std::string* FriendInfoResponse_PlayerInfo::mutable_email(int index) {
  return email_.Mutable(index);
}
inline void FriendInfoResponse_PlayerInfo::set_email(int index, const ::std::string& value) {
  email_.Mutable(index)->assign(value);
}
inline void FriendInfoResponse_PlayerInfo::set_email(int index, const char* value) {
  email_.Mutable(index)->assign(value);
}
inline void FriendInfoResponse_PlayerInfo::set_email(int index, const char* value, size_t size) {
  email_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FriendInfoResponse_PlayerInfo::add_email() {
  return email_.Add();
}
inline void FriendInfoResponse_PlayerInfo::add_email(const ::std::string& value) {
  email_.Add()->assign(value);
}
inline void FriendInfoResponse_PlayerInfo::add_email(const char* value) {
  email_.Add()->assign(value);
}
inline void FriendInfoResponse_PlayerInfo::add_email(const char* value, size_t size) {
  email_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FriendInfoResponse_PlayerInfo::email() const {
  return email_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FriendInfoResponse_PlayerInfo::mutable_email() {
  return &email_;
}

// -------------------------------------------------------------------

// FriendInfoResponse

// optional .message.FriendInfoResponse.PlayerInfoList friendList = 1;
inline bool FriendInfoResponse::has_friendlist() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FriendInfoResponse::set_has_friendlist() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FriendInfoResponse::clear_has_friendlist() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FriendInfoResponse::clear_friendlist() {
  if (friendlist_ != NULL) friendlist_->::message::FriendInfoResponse_PlayerInfoList::Clear();
  clear_has_friendlist();
}
inline const ::message::FriendInfoResponse_PlayerInfoList& FriendInfoResponse::friendlist() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return friendlist_ != NULL ? *friendlist_ : *default_instance().friendlist_;
#else
  return friendlist_ != NULL ? *friendlist_ : *default_instance_->friendlist_;
#endif
}
inline ::message::FriendInfoResponse_PlayerInfoList* FriendInfoResponse::mutable_friendlist() {
  set_has_friendlist();
  if (friendlist_ == NULL) friendlist_ = new ::message::FriendInfoResponse_PlayerInfoList;
  return friendlist_;
}
inline ::message::FriendInfoResponse_PlayerInfoList* FriendInfoResponse::release_friendlist() {
  clear_has_friendlist();
  ::message::FriendInfoResponse_PlayerInfoList* temp = friendlist_;
  friendlist_ = NULL;
  return temp;
}
inline void FriendInfoResponse::set_allocated_friendlist(::message::FriendInfoResponse_PlayerInfoList* friendlist) {
  delete friendlist_;
  friendlist_ = friendlist;
  if (friendlist) {
    set_has_friendlist();
  } else {
    clear_has_friendlist();
  }
}

// optional .message.FriendInfoResponse.PlayerInfoList enemyList = 2;
inline bool FriendInfoResponse::has_enemylist() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FriendInfoResponse::set_has_enemylist() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FriendInfoResponse::clear_has_enemylist() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FriendInfoResponse::clear_enemylist() {
  if (enemylist_ != NULL) enemylist_->::message::FriendInfoResponse_PlayerInfoList::Clear();
  clear_has_enemylist();
}
inline const ::message::FriendInfoResponse_PlayerInfoList& FriendInfoResponse::enemylist() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return enemylist_ != NULL ? *enemylist_ : *default_instance().enemylist_;
#else
  return enemylist_ != NULL ? *enemylist_ : *default_instance_->enemylist_;
#endif
}
inline ::message::FriendInfoResponse_PlayerInfoList* FriendInfoResponse::mutable_enemylist() {
  set_has_enemylist();
  if (enemylist_ == NULL) enemylist_ = new ::message::FriendInfoResponse_PlayerInfoList;
  return enemylist_;
}
inline ::message::FriendInfoResponse_PlayerInfoList* FriendInfoResponse::release_enemylist() {
  clear_has_enemylist();
  ::message::FriendInfoResponse_PlayerInfoList* temp = enemylist_;
  enemylist_ = NULL;
  return temp;
}
inline void FriendInfoResponse::set_allocated_enemylist(::message::FriendInfoResponse_PlayerInfoList* enemylist) {
  delete enemylist_;
  enemylist_ = enemylist;
  if (enemylist) {
    set_has_enemylist();
  } else {
    clear_has_enemylist();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace message

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_FriendInfo_2eproto__INCLUDED
