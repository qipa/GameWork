// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: HSGameGuide.proto

#ifndef PROTOBUF_HSGameGuide_2eproto__INCLUDED
#define PROTOBUF_HSGameGuide_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace message {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_HSGameGuide_2eproto();
void protobuf_AssignDesc_HSGameGuide_2eproto();
void protobuf_ShutdownFile_HSGameGuide_2eproto();

class GameGuide;
class GameGuide_Guide;
class GameGuide_Guide_Rect;
class GameGuide_Guide_Point;

enum GameGuide_Guide_ModeType {
  GameGuide_Guide_ModeType_ModeType_Round = 1,
  GameGuide_Guide_ModeType_ModeType_Rect = 2
};
bool GameGuide_Guide_ModeType_IsValid(int value);
const GameGuide_Guide_ModeType GameGuide_Guide_ModeType_ModeType_MIN = GameGuide_Guide_ModeType_ModeType_Round;
const GameGuide_Guide_ModeType GameGuide_Guide_ModeType_ModeType_MAX = GameGuide_Guide_ModeType_ModeType_Rect;
const int GameGuide_Guide_ModeType_ModeType_ARRAYSIZE = GameGuide_Guide_ModeType_ModeType_MAX + 1;

enum GameGuide_Guide_TouchType {
  GameGuide_Guide_TouchType_TouchType_leak = 1,
  GameGuide_Guide_TouchType_TouchType_intercept = 2
};
bool GameGuide_Guide_TouchType_IsValid(int value);
const GameGuide_Guide_TouchType GameGuide_Guide_TouchType_TouchType_MIN = GameGuide_Guide_TouchType_TouchType_leak;
const GameGuide_Guide_TouchType GameGuide_Guide_TouchType_TouchType_MAX = GameGuide_Guide_TouchType_TouchType_intercept;
const int GameGuide_Guide_TouchType_TouchType_ARRAYSIZE = GameGuide_Guide_TouchType_TouchType_MAX + 1;

// ===================================================================

class GameGuide_Guide_Rect : public ::google::protobuf::MessageLite {
 public:
  GameGuide_Guide_Rect();
  virtual ~GameGuide_Guide_Rect();
  
  GameGuide_Guide_Rect(const GameGuide_Guide_Rect& from);
  
  inline GameGuide_Guide_Rect& operator=(const GameGuide_Guide_Rect& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GameGuide_Guide_Rect& default_instance();
  
  void Swap(GameGuide_Guide_Rect* other);
  
  // implements Message ----------------------------------------------
  
  GameGuide_Guide_Rect* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameGuide_Guide_Rect& from);
  void MergeFrom(const GameGuide_Guide_Rect& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);
  
  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);
  
  // required float w = 3;
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 3;
  inline float w() const;
  inline void set_w(float value);
  
  // required float h = 4;
  inline bool has_h() const;
  inline void clear_h();
  static const int kHFieldNumber = 4;
  inline float h() const;
  inline void set_h(float value);
  
  // @@protoc_insertion_point(class_scope:message.GameGuide.Guide.Rect)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_w();
  inline void clear_has_w();
  inline void set_has_h();
  inline void clear_has_h();
  
  float x_;
  float y_;
  float w_;
  float h_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_HSGameGuide_2eproto();
  friend void protobuf_AssignDesc_HSGameGuide_2eproto();
  friend void protobuf_ShutdownFile_HSGameGuide_2eproto();
  
  void InitAsDefaultInstance();
  static GameGuide_Guide_Rect* default_instance_;
};
// -------------------------------------------------------------------

class GameGuide_Guide_Point : public ::google::protobuf::MessageLite {
 public:
  GameGuide_Guide_Point();
  virtual ~GameGuide_Guide_Point();
  
  GameGuide_Guide_Point(const GameGuide_Guide_Point& from);
  
  inline GameGuide_Guide_Point& operator=(const GameGuide_Guide_Point& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GameGuide_Guide_Point& default_instance();
  
  void Swap(GameGuide_Guide_Point* other);
  
  // implements Message ----------------------------------------------
  
  GameGuide_Guide_Point* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameGuide_Guide_Point& from);
  void MergeFrom(const GameGuide_Guide_Point& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);
  
  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);
  
  // @@protoc_insertion_point(class_scope:message.GameGuide.Guide.Point)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  
  float x_;
  float y_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_HSGameGuide_2eproto();
  friend void protobuf_AssignDesc_HSGameGuide_2eproto();
  friend void protobuf_ShutdownFile_HSGameGuide_2eproto();
  
  void InitAsDefaultInstance();
  static GameGuide_Guide_Point* default_instance_;
};
// -------------------------------------------------------------------

class GameGuide_Guide : public ::google::protobuf::MessageLite {
 public:
  GameGuide_Guide();
  virtual ~GameGuide_Guide();
  
  GameGuide_Guide(const GameGuide_Guide& from);
  
  inline GameGuide_Guide& operator=(const GameGuide_Guide& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GameGuide_Guide& default_instance();
  
  void Swap(GameGuide_Guide* other);
  
  // implements Message ----------------------------------------------
  
  GameGuide_Guide* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameGuide_Guide& from);
  void MergeFrom(const GameGuide_Guide& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef GameGuide_Guide_Rect Rect;
  typedef GameGuide_Guide_Point Point;
  
  typedef GameGuide_Guide_ModeType ModeType;
  static const ModeType ModeType_Round = GameGuide_Guide_ModeType_ModeType_Round;
  static const ModeType ModeType_Rect = GameGuide_Guide_ModeType_ModeType_Rect;
  static inline bool ModeType_IsValid(int value) {
    return GameGuide_Guide_ModeType_IsValid(value);
  }
  static const ModeType ModeType_MIN =
    GameGuide_Guide_ModeType_ModeType_MIN;
  static const ModeType ModeType_MAX =
    GameGuide_Guide_ModeType_ModeType_MAX;
  static const int ModeType_ARRAYSIZE =
    GameGuide_Guide_ModeType_ModeType_ARRAYSIZE;
  
  typedef GameGuide_Guide_TouchType TouchType;
  static const TouchType TouchType_leak = GameGuide_Guide_TouchType_TouchType_leak;
  static const TouchType TouchType_intercept = GameGuide_Guide_TouchType_TouchType_intercept;
  static inline bool TouchType_IsValid(int value) {
    return GameGuide_Guide_TouchType_IsValid(value);
  }
  static const TouchType TouchType_MIN =
    GameGuide_Guide_TouchType_TouchType_MIN;
  static const TouchType TouchType_MAX =
    GameGuide_Guide_TouchType_TouchType_MAX;
  static const int TouchType_ARRAYSIZE =
    GameGuide_Guide_TouchType_TouchType_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // required .message.GameGuide.Guide.ModeType modeType = 2;
  inline bool has_modetype() const;
  inline void clear_modetype();
  static const int kModeTypeFieldNumber = 2;
  inline ::message::GameGuide_Guide_ModeType modetype() const;
  inline void set_modetype(::message::GameGuide_Guide_ModeType value);
  
  // repeated .message.GameGuide.Guide.Rect rect = 3;
  inline int rect_size() const;
  inline void clear_rect();
  static const int kRectFieldNumber = 3;
  inline const ::message::GameGuide_Guide_Rect& rect(int index) const;
  inline ::message::GameGuide_Guide_Rect* mutable_rect(int index);
  inline ::message::GameGuide_Guide_Rect* add_rect();
  inline const ::google::protobuf::RepeatedPtrField< ::message::GameGuide_Guide_Rect >&
      rect() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::GameGuide_Guide_Rect >*
      mutable_rect();
  
  // repeated .message.GameGuide.Guide.Point pointList = 4;
  inline int pointlist_size() const;
  inline void clear_pointlist();
  static const int kPointListFieldNumber = 4;
  inline const ::message::GameGuide_Guide_Point& pointlist(int index) const;
  inline ::message::GameGuide_Guide_Point* mutable_pointlist(int index);
  inline ::message::GameGuide_Guide_Point* add_pointlist();
  inline const ::google::protobuf::RepeatedPtrField< ::message::GameGuide_Guide_Point >&
      pointlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::GameGuide_Guide_Point >*
      mutable_pointlist();
  
  // repeated float diameter = 5;
  inline int diameter_size() const;
  inline void clear_diameter();
  static const int kDiameterFieldNumber = 5;
  inline float diameter(int index) const;
  inline void set_diameter(int index, float value);
  inline void add_diameter(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      diameter() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_diameter();
  
  // repeated float multiple = 6;
  inline int multiple_size() const;
  inline void clear_multiple();
  static const int kMultipleFieldNumber = 6;
  inline float multiple(int index) const;
  inline void set_multiple(int index, float value);
  inline void add_multiple(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      multiple() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_multiple();
  
  // optional .message.GameGuide.Guide.Point describePos = 7;
  inline bool has_describepos() const;
  inline void clear_describepos();
  static const int kDescribePosFieldNumber = 7;
  inline const ::message::GameGuide_Guide_Point& describepos() const;
  inline ::message::GameGuide_Guide_Point* mutable_describepos();
  inline ::message::GameGuide_Guide_Point* release_describepos();
  
  // optional .message.GameGuide.Guide.TouchType touchType = 8;
  inline bool has_touchtype() const;
  inline void clear_touchtype();
  static const int kTouchTypeFieldNumber = 8;
  inline ::message::GameGuide_Guide_TouchType touchtype() const;
  inline void set_touchtype(::message::GameGuide_Guide_TouchType value);
  
  // optional string describe = 9 [default = ""];
  inline bool has_describe() const;
  inline void clear_describe();
  static const int kDescribeFieldNumber = 9;
  inline const ::std::string& describe() const;
  inline void set_describe(const ::std::string& value);
  inline void set_describe(const char* value);
  inline void set_describe(const char* value, size_t size);
  inline ::std::string* mutable_describe();
  inline ::std::string* release_describe();
  
  // @@protoc_insertion_point(class_scope:message.GameGuide.Guide)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_modetype();
  inline void clear_has_modetype();
  inline void set_has_describepos();
  inline void clear_has_describepos();
  inline void set_has_touchtype();
  inline void clear_has_touchtype();
  inline void set_has_describe();
  inline void clear_has_describe();
  
  ::google::protobuf::int32 id_;
  int modetype_;
  ::google::protobuf::RepeatedPtrField< ::message::GameGuide_Guide_Rect > rect_;
  ::google::protobuf::RepeatedPtrField< ::message::GameGuide_Guide_Point > pointlist_;
  ::google::protobuf::RepeatedField< float > diameter_;
  ::google::protobuf::RepeatedField< float > multiple_;
  ::message::GameGuide_Guide_Point* describepos_;
  ::std::string* describe_;
  int touchtype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_HSGameGuide_2eproto();
  friend void protobuf_AssignDesc_HSGameGuide_2eproto();
  friend void protobuf_ShutdownFile_HSGameGuide_2eproto();
  
  void InitAsDefaultInstance();
  static GameGuide_Guide* default_instance_;
};
// -------------------------------------------------------------------

class GameGuide : public ::google::protobuf::MessageLite {
 public:
  GameGuide();
  virtual ~GameGuide();
  
  GameGuide(const GameGuide& from);
  
  inline GameGuide& operator=(const GameGuide& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GameGuide& default_instance();
  
  void Swap(GameGuide* other);
  
  // implements Message ----------------------------------------------
  
  GameGuide* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameGuide& from);
  void MergeFrom(const GameGuide& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef GameGuide_Guide Guide;
  
  // accessors -------------------------------------------------------
  
  // repeated .message.GameGuide.Guide guideList = 1;
  inline int guidelist_size() const;
  inline void clear_guidelist();
  static const int kGuideListFieldNumber = 1;
  inline const ::message::GameGuide_Guide& guidelist(int index) const;
  inline ::message::GameGuide_Guide* mutable_guidelist(int index);
  inline ::message::GameGuide_Guide* add_guidelist();
  inline const ::google::protobuf::RepeatedPtrField< ::message::GameGuide_Guide >&
      guidelist() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::GameGuide_Guide >*
      mutable_guidelist();
  
  // @@protoc_insertion_point(class_scope:message.GameGuide)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::message::GameGuide_Guide > guidelist_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_HSGameGuide_2eproto();
  friend void protobuf_AssignDesc_HSGameGuide_2eproto();
  friend void protobuf_ShutdownFile_HSGameGuide_2eproto();
  
  void InitAsDefaultInstance();
  static GameGuide* default_instance_;
};
// ===================================================================


// ===================================================================

// GameGuide_Guide_Rect

// required float x = 1;
inline bool GameGuide_Guide_Rect::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameGuide_Guide_Rect::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameGuide_Guide_Rect::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameGuide_Guide_Rect::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float GameGuide_Guide_Rect::x() const {
  return x_;
}
inline void GameGuide_Guide_Rect::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 2;
inline bool GameGuide_Guide_Rect::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameGuide_Guide_Rect::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameGuide_Guide_Rect::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameGuide_Guide_Rect::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float GameGuide_Guide_Rect::y() const {
  return y_;
}
inline void GameGuide_Guide_Rect::set_y(float value) {
  set_has_y();
  y_ = value;
}

// required float w = 3;
inline bool GameGuide_Guide_Rect::has_w() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameGuide_Guide_Rect::set_has_w() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameGuide_Guide_Rect::clear_has_w() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameGuide_Guide_Rect::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline float GameGuide_Guide_Rect::w() const {
  return w_;
}
inline void GameGuide_Guide_Rect::set_w(float value) {
  set_has_w();
  w_ = value;
}

// required float h = 4;
inline bool GameGuide_Guide_Rect::has_h() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameGuide_Guide_Rect::set_has_h() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameGuide_Guide_Rect::clear_has_h() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameGuide_Guide_Rect::clear_h() {
  h_ = 0;
  clear_has_h();
}
inline float GameGuide_Guide_Rect::h() const {
  return h_;
}
inline void GameGuide_Guide_Rect::set_h(float value) {
  set_has_h();
  h_ = value;
}

// -------------------------------------------------------------------

// GameGuide_Guide_Point

// required float x = 1;
inline bool GameGuide_Guide_Point::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameGuide_Guide_Point::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameGuide_Guide_Point::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameGuide_Guide_Point::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float GameGuide_Guide_Point::x() const {
  return x_;
}
inline void GameGuide_Guide_Point::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 2;
inline bool GameGuide_Guide_Point::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameGuide_Guide_Point::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameGuide_Guide_Point::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameGuide_Guide_Point::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float GameGuide_Guide_Point::y() const {
  return y_;
}
inline void GameGuide_Guide_Point::set_y(float value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// GameGuide_Guide

// required int32 id = 1;
inline bool GameGuide_Guide::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameGuide_Guide::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameGuide_Guide::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameGuide_Guide::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 GameGuide_Guide::id() const {
  return id_;
}
inline void GameGuide_Guide::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required .message.GameGuide.Guide.ModeType modeType = 2;
inline bool GameGuide_Guide::has_modetype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameGuide_Guide::set_has_modetype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameGuide_Guide::clear_has_modetype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameGuide_Guide::clear_modetype() {
  modetype_ = 1;
  clear_has_modetype();
}
inline ::message::GameGuide_Guide_ModeType GameGuide_Guide::modetype() const {
  return static_cast< ::message::GameGuide_Guide_ModeType >(modetype_);
}
inline void GameGuide_Guide::set_modetype(::message::GameGuide_Guide_ModeType value) {
  GOOGLE_DCHECK(::message::GameGuide_Guide_ModeType_IsValid(value));
  set_has_modetype();
  modetype_ = value;
}

// repeated .message.GameGuide.Guide.Rect rect = 3;
inline int GameGuide_Guide::rect_size() const {
  return rect_.size();
}
inline void GameGuide_Guide::clear_rect() {
  rect_.Clear();
}
inline const ::message::GameGuide_Guide_Rect& GameGuide_Guide::rect(int index) const {
  return rect_.Get(index);
}
inline ::message::GameGuide_Guide_Rect* GameGuide_Guide::mutable_rect(int index) {
  return rect_.Mutable(index);
}
inline ::message::GameGuide_Guide_Rect* GameGuide_Guide::add_rect() {
  return rect_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::GameGuide_Guide_Rect >&
GameGuide_Guide::rect() const {
  return rect_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::GameGuide_Guide_Rect >*
GameGuide_Guide::mutable_rect() {
  return &rect_;
}

// repeated .message.GameGuide.Guide.Point pointList = 4;
inline int GameGuide_Guide::pointlist_size() const {
  return pointlist_.size();
}
inline void GameGuide_Guide::clear_pointlist() {
  pointlist_.Clear();
}
inline const ::message::GameGuide_Guide_Point& GameGuide_Guide::pointlist(int index) const {
  return pointlist_.Get(index);
}
inline ::message::GameGuide_Guide_Point* GameGuide_Guide::mutable_pointlist(int index) {
  return pointlist_.Mutable(index);
}
inline ::message::GameGuide_Guide_Point* GameGuide_Guide::add_pointlist() {
  return pointlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::GameGuide_Guide_Point >&
GameGuide_Guide::pointlist() const {
  return pointlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::GameGuide_Guide_Point >*
GameGuide_Guide::mutable_pointlist() {
  return &pointlist_;
}

// repeated float diameter = 5;
inline int GameGuide_Guide::diameter_size() const {
  return diameter_.size();
}
inline void GameGuide_Guide::clear_diameter() {
  diameter_.Clear();
}
inline float GameGuide_Guide::diameter(int index) const {
  return diameter_.Get(index);
}
inline void GameGuide_Guide::set_diameter(int index, float value) {
  diameter_.Set(index, value);
}
inline void GameGuide_Guide::add_diameter(float value) {
  diameter_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
GameGuide_Guide::diameter() const {
  return diameter_;
}
inline ::google::protobuf::RepeatedField< float >*
GameGuide_Guide::mutable_diameter() {
  return &diameter_;
}

// repeated float multiple = 6;
inline int GameGuide_Guide::multiple_size() const {
  return multiple_.size();
}
inline void GameGuide_Guide::clear_multiple() {
  multiple_.Clear();
}
inline float GameGuide_Guide::multiple(int index) const {
  return multiple_.Get(index);
}
inline void GameGuide_Guide::set_multiple(int index, float value) {
  multiple_.Set(index, value);
}
inline void GameGuide_Guide::add_multiple(float value) {
  multiple_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
GameGuide_Guide::multiple() const {
  return multiple_;
}
inline ::google::protobuf::RepeatedField< float >*
GameGuide_Guide::mutable_multiple() {
  return &multiple_;
}

// optional .message.GameGuide.Guide.Point describePos = 7;
inline bool GameGuide_Guide::has_describepos() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GameGuide_Guide::set_has_describepos() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GameGuide_Guide::clear_has_describepos() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GameGuide_Guide::clear_describepos() {
  if (describepos_ != NULL) describepos_->::message::GameGuide_Guide_Point::Clear();
  clear_has_describepos();
}
inline const ::message::GameGuide_Guide_Point& GameGuide_Guide::describepos() const {
  return describepos_ != NULL ? *describepos_ : *default_instance_->describepos_;
}
inline ::message::GameGuide_Guide_Point* GameGuide_Guide::mutable_describepos() {
  set_has_describepos();
  if (describepos_ == NULL) describepos_ = new ::message::GameGuide_Guide_Point;
  return describepos_;
}
inline ::message::GameGuide_Guide_Point* GameGuide_Guide::release_describepos() {
  clear_has_describepos();
  ::message::GameGuide_Guide_Point* temp = describepos_;
  describepos_ = NULL;
  return temp;
}

// optional .message.GameGuide.Guide.TouchType touchType = 8;
inline bool GameGuide_Guide::has_touchtype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GameGuide_Guide::set_has_touchtype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GameGuide_Guide::clear_has_touchtype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GameGuide_Guide::clear_touchtype() {
  touchtype_ = 1;
  clear_has_touchtype();
}
inline ::message::GameGuide_Guide_TouchType GameGuide_Guide::touchtype() const {
  return static_cast< ::message::GameGuide_Guide_TouchType >(touchtype_);
}
inline void GameGuide_Guide::set_touchtype(::message::GameGuide_Guide_TouchType value) {
  GOOGLE_DCHECK(::message::GameGuide_Guide_TouchType_IsValid(value));
  set_has_touchtype();
  touchtype_ = value;
}

// optional string describe = 9 [default = ""];
inline bool GameGuide_Guide::has_describe() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GameGuide_Guide::set_has_describe() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GameGuide_Guide::clear_has_describe() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GameGuide_Guide::clear_describe() {
  if (describe_ != &::google::protobuf::internal::kEmptyString) {
    describe_->clear();
  }
  clear_has_describe();
}
inline const ::std::string& GameGuide_Guide::describe() const {
  return *describe_;
}
inline void GameGuide_Guide::set_describe(const ::std::string& value) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(value);
}
inline void GameGuide_Guide::set_describe(const char* value) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(value);
}
inline void GameGuide_Guide::set_describe(const char* value, size_t size) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameGuide_Guide::mutable_describe() {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  return describe_;
}
inline ::std::string* GameGuide_Guide::release_describe() {
  clear_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = describe_;
    describe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GameGuide

// repeated .message.GameGuide.Guide guideList = 1;
inline int GameGuide::guidelist_size() const {
  return guidelist_.size();
}
inline void GameGuide::clear_guidelist() {
  guidelist_.Clear();
}
inline const ::message::GameGuide_Guide& GameGuide::guidelist(int index) const {
  return guidelist_.Get(index);
}
inline ::message::GameGuide_Guide* GameGuide::mutable_guidelist(int index) {
  return guidelist_.Mutable(index);
}
inline ::message::GameGuide_Guide* GameGuide::add_guidelist() {
  return guidelist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::GameGuide_Guide >&
GameGuide::guidelist() const {
  return guidelist_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::GameGuide_Guide >*
GameGuide::mutable_guidelist() {
  return &guidelist_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace message

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_HSGameGuide_2eproto__INCLUDED
